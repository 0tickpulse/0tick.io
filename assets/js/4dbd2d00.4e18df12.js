"use strict";(self.webpackChunk_0_tick_io=self.webpackChunk_0_tick_io||[]).push([[991],{6313:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=s(1527),a=s(7463);const r={},i="Arrays",o={id:"notes/programming/DSA/Arrays/index",title:"Arrays",description:"They're secretly objects with the number index as properties to act like arrays.",source:"@site/docs/notes/programming/DSA/Arrays/index.md",sourceDirName:"notes/programming/DSA/Arrays",slug:"/notes/programming/DSA/Arrays/",permalink:"/notes/programming/DSA/Arrays/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/notes/programming/DSA/Arrays/index.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebarNotes",previous:{title:"Introduction",permalink:"/notes/intro"},next:{title:"Big-O Notation",permalink:"/notes/programming/DSA/Big-O Notation/"}},c={},d=[{value:"Indexing",id:"indexing",level:2},{value:"ArrayBuffers in JavaScript",id:"arraybuffers-in-javascript",level:2},{value:"Arrays are not lists",id:"arrays-are-not-lists",level:2},{value:"Insertion",id:"insertion",level:2},{value:"Deletion",id:"deletion",level:2},{value:"Lists",id:"lists",level:2}];function l(e){const n={admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"arrays",children:"Arrays"}),"\n",(0,t.jsx)(n.admonition,{title:"JavaScript arrays aren't arrays",type:"info",children:(0,t.jsx)(n.p,{children:"They're secretly objects with the number index as properties to act like arrays."})}),"\n",(0,t.jsx)(n.p,{children:"An array is a contiguous memory space that contains a certain number of bytes."}),"\n",(0,t.jsxs)(n.p,{children:["For example, ",(0,t.jsx)(n.code,{children:"int[3]"})," means three integers in contiguous space (12 bytes)."]}),"\n",(0,t.jsx)(n.h2,{id:"indexing",children:"Indexing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let arr = [1, 2, 3]; // int[3]\narr[0]; // 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In memory, this array looks like ",(0,t.jsx)(n.code,{children:"00 00 00 01 00 00 00 02 00 00 00 03"}),".\nWhen we index into an array, we're getting the address of the first element and adding the index multiplied by the size of the type to it.\nIf it was ",(0,t.jsx)(n.code,{children:"arr[2]"}),", we'd get the address of the first element and add ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mn,{children:"2"}),(0,t.jsx)(n.mo,{children:"\u2217"}),(0,t.jsx)(n.mn,{children:"4"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"2 * 4"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,t.jsx)(n.span,{className:"mord",children:"2"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,t.jsx)(n.span,{className:"mord",children:"4"})]})]})]})," to it.\nThis has ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]})," time complexity."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"00 00 00 01 00 00 00 02 00 00 00 03\n^           ^           ^\n|           |           |\n|           |           +--- arr[2] (2 * 4)\n|           +--- arr[1] (1 * 4)\n+--- arr[0] (0 * 4)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a function that indexes an array, to demonstrate the above in code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn index<T: Copy>(arr: &[T], index: usize) -> T {\n    let address = arr.as_ptr() as usize;\n    let size = std::mem::size_of::<T>();\n    let offset = index * size;\n    let new_address = address + offset;\n    unsafe { *(new_address as *const T) }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is why array indexes start at 0; it's closer to how the array is stored in memory."}),"\n",(0,t.jsx)(n.h2,{id:"arraybuffers-in-javascript",children:"ArrayBuffers in JavaScript"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"> const buffer = new ArrayBuffer(12)\nundefined\n> buffer\nArrayBuffer {\n  [Uint8Contents]: <00 00 00 00 00 00 00 00 00 00 00 00>,\n  byteLength: 12\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"It's just a series of 12 bytes. If we want to interpret it as something else, we can use a typed array."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"> const v8 = new Uint8Array(buffer)\nundefined\n> v8\nUint8Array(12) [\n  0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0,\n  0, 0\n]\n> v8[0] = 42\n42\n> v8[2] = 60\n60\n> v8\nUint8Array(12) [\n  42, 0, 60, 0, 0,\n   0, 0,  0, 0, 0,\n   0, 0\n]\nArrayBuffer {\n  [Uint8Contents]: <2a 00 3c 00 00 00 00 00 00 00 00 00>,\n  byteLength: 12\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Notice how one byte was skipped because of the size of the type."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"> const v16 = new Uint16Array(buffer)\nundefined\n> view16[4] = 0x5050\n20560\n> buffer\nArrayBuffer {\n  [Uint8Contents]: <2a 00 3c 00 00 00 00 00 50 50 00 00>,\n  byteLength: 12\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is interesting because we set position 4, yet it sets it on the 8th and 9th bytes.\nAgain, this is because of the size of the type, and how that affects the interpretation of the buffer.\nAdditionally, a concept called ",(0,t.jsx)(n.strong,{children:"endianness"}),", i.e. the order of bytes, comes into play here."]}),"\n",(0,t.jsxs)(n.p,{children:["When we used ",(0,t.jsx)(n.code,{children:"Uint8Array"}),", we interpreted it as 8-bit units, while ",(0,t.jsx)(n.code,{children:"Uint16Array"})," interprets it as 16-bit units.\nThis is what an array fundamentally is; a contiguous memory space interpreted as a certain type."]}),"\n",(0,t.jsxs)(n.p,{children:["These are called ",(0,t.jsx)(n.strong,{children:"views"})," because they're a different way of looking at the same data."]}),"\n",(0,t.jsx)(n.h2,{id:"arrays-are-not-lists",children:"Arrays are not lists"}),"\n",(0,t.jsx)(n.p,{children:"Arrays are not lists, and lists are not arrays."}),"\n",(0,t.jsx)(n.h2,{id:"insertion",children:"Insertion"}),"\n",(0,t.jsx)(n.p,{children:"With arrays, there's no magic behind the scenes.\nThere's no \"insertion,\" it just sets the value at the index.\nYou do not get to grow your array, because it can overwrite other data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"01 02 03 04 05 06 07 08 09 10 11 12 13 14 15\n----------------------------+ -------------+\n                            |              |\n                            |              +--- some other data\n                            +--- our array\n"})}),"\n",(0,t.jsx)(n.p,{children:"It would be problematic if we wanted to grow our array, because it's going to overlap with other data."}),"\n",(0,t.jsx)(n.p,{children:"This is why data structures exist; to abstract away the details of how data is stored, so you don't have to constantly reallocate memory and move data around."}),"\n",(0,t.jsxs)(n.p,{children:["Some languages have things like ",(0,t.jsx)(n.code,{children:"capacity"})," that optimizes the use of memory without reallocations."]}),"\n",(0,t.jsx)(n.h2,{id:"deletion",children:"Deletion"}),"\n",(0,t.jsx)(n.p,{children:'Deletion is a bit confusing; you don\'t "delete" contiguous memory.\nPrograms delete things differently, but the most common way is to mark it as "deleted" and ignore it.'}),"\n",(0,t.jsx)(n.p,{children:"For raw arrays in, for instance, C, you will have to mark it yourself."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"null"}),' also comes into play here as a named way of saying "deleted."']}),"\n",(0,t.jsx)(n.h2,{id:"lists",children:"Lists"}),"\n",(0,t.jsxs)(n.p,{children:["As previously mentioned, arrays are just contiguous memory interpreted as a certain type.\nYou can't \"insert at a certain index\" because you can't grow the array. There's no ",(0,t.jsx)(n.code,{children:"push"}),", ",(0,t.jsx)(n.code,{children:"pop"}),", etc.\nTo get around this, data structures are used, many of which actually use arrays under the hood."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},7463:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>i});var t=s(959);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);