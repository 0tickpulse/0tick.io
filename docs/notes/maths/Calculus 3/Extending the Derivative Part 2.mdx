---
sidebar_position: 4
---

import { Mafs, Coordinates, Plot, Line, Circle, Theme, useMovablePoint, MovablePoint, useStopwatch, vec, Vector, LaTeX, Polygon, Transform, labelPi, Point, Text } from "mafs";

import { useState, useEffect, useRef, useCallback, useMemo, memo, Fragment } from "react";
import { lineLabel } from "@site/src/utilities/lines";
import { color, getColorFromMagnitude, gradient } from "@site/src/utilities/colors";
import TOCInline from '@theme/TOCInline';
import * as MB from "mathbox-react";
import * as THREE from "three";
import range from "lodash/range";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { easeInOutCubic } from "js-easing-functions";

# Extending the Derivative: Part 2 (Old Notes)

Previously, we discussed some fundamentals in Multivariable Calculus, including the concept of partial derivatives and the gradient.
Now we will discuss some more advanced topics, and as a bonus, apply them to some real-world problems, including Maxwell's Equations.

We will cover the divergence, curl, and Laplacian **operators**. They are operators in that they take a function as input and return another function.
Operators have shown up before, such as the derivative operator $\dv{x}$, and the gradient operator $\grad$.

## Table of Contents

<TOCInline toc={toc} />

## Divergence

### Intuitition for Divergence

Before discussing the formula for divergence, let's first understand what it is.
Consider a vector field $\va{F}$ in 2D space. To drill in the intuition, consider it representing the flow of some water.

<DivergenceVisualization />

Consider a region in the space.
In this region, consider how much water is flowing in and out of the region. This is called the **divergence** of the vector field.
For example, set the region to be around the origin. Consider the following vector field:

<DivergenceVisualization
    f={([x, y]) => [x, y]}
    df={([x, y]) => [1, 1]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
    xRange={[-10, 10, 0.5]}
    yRange={[-10, 10, 0.5]}
    sources={[
        [0.5, 0],
        [0, 0.5],
        [-0.5, 0],
        [0, -0.5],
    ]}
/>

In this case, the water is flowing out of the region. In this case, the divergence is positive.
Note that a positive divergence doesn't mean that all the water is flowing out of the region. It just means that more water is flowing out than in.
For example, the divergence here is also positive:

<DivergenceVisualization
    f={([x, y]) => [(x + 7) / 5, 0]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
/>

Regions where the divergence is positive are called **sources**. In the water example, the source could be from a fountain.
Next, consider the following vector field:

<DivergenceVisualization f={([x, y]) => [-x, -y]} mafsNodes={<Circle center={[0, 0]} radius={2} />} />

We flipped the vector field, so now the water is flowing into the region, and the divergence is negative.
Regions where the divergence is negative are called **sinks**. In the water example, the sink could be a drain.

Of course, this is not how water works in real life. Going back to the first example:

<DivergenceVisualization />

Notice that at any region, there's no net flow of water. The water is flowing out of the region as much as it is flowing into the region.
Water is **incompressible**, and the mathematical term for this is that the divergence of the vector field is zero.

### Formulation of Divergence

The notation for divergence we will currently use is $\operatorname{div} \va{F}(x, y)$ (although this is not the only notation).
As shown above, divergence is a scalar value, and the operator acts on a vector field.

First, consider a vector field in one dimension:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ 0]
\end{equation}
$$

This means that the water will only flow horizontally. Consider the case where the divergence is positive:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0
\end{equation}
$$

What this means visually is that the water is flowing out of the region more than it is flowing in.
On the left side of the region, $P < 0$, and on the right side, $P > 0$.

A visualization is shown below, split into two parts:

1. The point $(x, y)$, and a movable point $P(x, y)$.
2. The plot of $P(x, y)$ over $x$ (with $y$ fixed).

export function DivergencePlot({
    P = (x) => x,
}) {
    const movable = useMovablePoint([-1, 0], {
        constrain: ([x, y]) => [x, 0],
    });
    const point = movable.point;

    const graphOrigin = [8.5, 0]
    return (
        <Mafs viewBox={{ x: [-5, 15]}}>
            <Vector tail={point} tip={vec.add(point, [P(point[0]), 0])} />
            {movable.element}

            <Point x={0} y={0} />
            <LaTeX tex={"(x, y)"} at={[0, -0.5]} />

            <Transform translate={graphOrigin} >
                <Vector tip={[4, 0]} />
                <Vector tip={[0, 4]} />
                <Vector tip={[-4, 0]} />
                <Vector tip={[0, -4]} />
                <LaTeX tex={"P(x, y)"} at={[0, 4.5]} />
                <LaTeX tex={"x"} at={[4.5, 0]} />
            </Transform>
            <Plot.Parametric
                xy={(t) => [
                    t,
                    P(t - graphOrigin[0]) + graphOrigin[1],
                ]}
                t={[graphOrigin[0] - 4, graphOrigin[0] + 4]}
            />
            <Point
                x={point[0] + graphOrigin[0]}
                y={P(point[0]) + graphOrigin[1]}
            />
        </Mafs>
    )
}

<DivergencePlot P={(x) => x} />

Meaning, it increases as we move to the right. This can be written as:

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

The second scenario is where there is a lot of water flowing out into the right, and some water flowing in from the left.
Recall that the divergence is still positive:

<DivergencePlot P={(x) => (x - 7) / 5 + 3} />

Notice that the slope of the graph is still positive, as it increases as we move to the right.

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

The last scenario is where there is a lot of water flowing out into the left, and some water flowing in from the right.

<DivergencePlot P={(x) => (x - 7) / 5} />

The slope of the graph is still positive, as it increases as we move to the right.
In this case, it's very negative at the left, and at the right, it is still negative, but less so. Hence,

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

It should be clear from these scenarios that:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0 \implies \pdv{P}{x} > 0
\end{equation}
$$

Hence, the partial derivative is somehow related to the divergence.
We can apply the same logic for the $y$ component of the vector field:

$$
\begin{equation}
\va{F}(x, y) = \mqty[0 \\ Q(x, y)]
\end{equation}
$$

In this case, the water will only flow vertically. Consider the case where the divergence is positive:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0 \implies \pdv{Q}{y} > 0
\end{equation}
$$

Now combine the two components:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

The divergence of this vector field is then defined as the sum of the partial derivatives of the components:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y}
\end{equation}
$$

There is something interesting about this formula. We only considered vector fields purely in the $x$ and $y$ directions.
In reality, vector fields can be in any direction. The formula for divergence still holds, since the vectors can always be decomposed into components in the $x$ and $y$ directions.
To use the intuitive example, you could consider a box around the origin, and consider the flow of water in and out of the box.
Then, the flow can be decomposed into the $x$ (left and right of the box) and $y$ (up and down of the box) directions.

### Example Problem: Evaluating Divergence

> The vector field $\va{F}(x, y)$ is given by:
>
> $$
> \begin{equation}
> \va{F}(x, y) = \mqty[x^2 + y^2 \\ 2xy]
> \end{equation}
> $$
>
> Evaluate the divergence of $\va{F}(x, y)$.

To evaluate the divergence, we need to find the partial derivatives of the components of the vector field.
Recall that partial derivatives are just like normal derivatives, but we treat the other variable as a constant.

First, define the components of the vector field:

$$
\begin{equation}
\va{F}(x, y) = \mqty[x^2 + y^2 \\ 2xy] = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Then, find the partial derivatives:

$$
\begin{align}
\pdv{P}{x} &= \pdv{}{x} (x^2 - y^2) = 2x \\
\pdv{Q}{y} &= \pdv{}{y} (2xy) = 2x
\end{align}
$$

Finally, evaluate the divergence:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y} = 2x + 2x = 4x
\end{equation}
$$

Hence, the divergence of $\va{F}(x, y)$ is $4x$.

<DivergenceVisualization
    f={([x, y]) => [x ** 2 - y ** 2, 2 * x * y]}
    df={([x, y]) => [4 * x, 0]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
/>

Consider some cases:

- When $x > 0$, the divergence is positive, so the water is flowing out of the region.
- When $x < 0$, the divergence is negative, so the water is flowing into the region.
- When $x = 0$, the divergence is zero, so there is no net flow of water.

### Nabla Notation for Divergence

Recall the symbol $\grad$ used for the gradient. The gradient is defined as:

$$
\begin{equation}
\grad{f(x, y)} = \mqty[\pdv{f}{x} \\ \pdv{f}{y}]
\end{equation}
$$

Where we define $\grad$ as:

$$
\begin{equation}
\grad = \mqty[\pdv{x} \\ \pdv{y}]
\end{equation}
$$

The divergence is defined as:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y} = \pdv{x} P(x, y) + \pdv{y} Q(x, y)
\end{equation}
$$

This is equivalent to the dot product of the nabla operator and the vector field:

$$
\begin{equation}
\begin{split}
\operatorname{div} \va{F}(x, y) &= \class{blue}{\pdv{x}} \class{yellow}{P(x, y)} + \class{blue}{\pdv{y}} \class{yellow}{Q(x, y)} \\
&= \class{blue}{\mqty[\pdv{x} \\ \pdv{y}]} \cdot \class{yellow}{\mqty[P(x, y) \\ Q(x, y)]} \\
&= \class{blue}{\grad} \cdot \class{yellow}{\va{F}(x, y)}
\end{split}
\end{equation}
$$

Hence, the divergence can be written as:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \div \va{F}(x, y)
\end{equation}
$$

Not only does this have symbolic significance, but it also reflects another way to think about divergence intuitively, which will be discussed in [a later section](#interpretations-of-divergence-and-curl-with-its-formulas).

### The First Maxwell Equation: Gauss's Law

Now that we have discussed divergence, we can apply it to the first Maxwell equation: Gauss's Law.

It describes how the electric field $\class{yellow}{\va{E}}$ is related to the charge density $\rho$.

$$
\begin{equation}
\div \class{yellow}{\va{E}} = \frac{\rho}{\varepsilon_0}
\end{equation}
$$

This is a direct proportionality. This means that as the charge density increases, the divergence of the electric field increases, which should make intuitive sense.

Consider a positive charge somewhere in space.
The charge density would then be positive, so the divergence of the electric field would be positive.
This means that the electric field points away from the charge.

Likewise, for a negative charge, the charge density would be negative, so the divergence of the electric field would be negative.

{(() => {
    // positive charge
    const movablePositive = useMovablePoint([2, 0], { color: color("green") });
    const posPoint = movablePositive.point;

    // negative charge
    const movableNegative = useMovablePoint([-2, 0], { color: color("red") });
    const negPoint = movableNegative.point;

    const field = ([x, y]) => {
        const positive = vec.sub([x, y], posPoint);
        const negative = vec.sub([x, y], negPoint);
        const positiveMagnitude = vec.mag(positive);
        const negativeMagnitude = vec.mag(negative);
        return [
            positive[0] / (positiveMagnitude ** 3) - negative[0] / (negativeMagnitude ** 3),
            positive[1] / (positiveMagnitude ** 3) - negative[1] / (negativeMagnitude ** 3),
        ]
    }

    return (
        <DivergenceVisualization
            f={field}
            df={([x, y]) => [0, 0]}
            mafsNodes={[
                movablePositive.element,
                movableNegative.element,
            ]}
            sources={[posPoint]}
        />
    );
})()}

### Divergence in Cylindrical and Spherical Coordinates

We have discussed divergence in Cartesian coordinates as the sum of the partial derivatives of the components:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y, z) = \pdv{P}{x} + \pdv{Q}{y} + \pdv{R}{z}
\end{equation}
$$

Consider a vector field in cylindrical coordinates:

$$
\begin{equation}
\va{F}(r, \theta, z) = P(r, \theta, z) \vu{r} + Q(r, \theta, z) \vu{\theta} + R(r, \theta, z) \vu{z}
\end{equation}
$$

The divergence of this vector field is then the sum of the partial derivatives of the components:

$$
\begin{equation}
\operatorname{div} \va{F}(r, \theta, z) = \frac{1}{r} \pdv{r} (r P) + \frac{1}{r} \pdv{\theta} Q + \pdv{R}{z}
\end{equation}
$$

Notice that it is similar to the Cartesian formula, but with some extra things to consider due to the cylindrical coordinates:

- The $r$ component has an extra $\frac{1}{r}$ factor.

### The Second Maxwell Equation: Gauss's Law for Magnetism

The second Maxwell equation describes how the magnetic field $\class{blue}{\va{B}}$ is related to the divergence of the magnetic field.
It simply states that the divergence of the magnetic field is zero:

$$
\begin{equation}
\div \class{blue}{\va{B}} = 0
\end{equation}
$$

Recall that a divergence of zero means that it's incompressible, just like the water example.
The magnetic field lines are always closed loops, and they never start or end.

One implication is that there are no magnetic monopoles, hypothetical things that have only a north or south pole.

The first two Maxwell equations are the most intuitive, and they are the most straightforward to understand.
They describe in complete detail electro_statics_ and magneto_statics_ - when they are **not changing over time**.
When they do change over time, things get more complicated, and the two fields start to interact with each other.
These interactions are described by the last two Maxwell equations.

## Curl

### Intuition for Curl in 2D

Consider a vector field $\va{F}$ in 2D space. Once again, we will consider it representing the flow of some water.

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}
/>

Focus on this specific region:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[3, 0]} radius={1} />}
/>

Notice that the water is flowing counterclockwise around this point.
When there's rotation in the vector field, we call it the **curl** of the vector field.
For counterclockwise rotation, the curl is positive.

Consider another region:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[0, 3]} radius={1} />}
/>

In this region, the water is flowing clockwise around this point, so the curl is negative.

Finally, consider a region where the water does not rotate:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[0, 0]} radius={1} />}
/>

In this case, the curl is zero.

### Formulation of Curl in 2D

The notation for curl is $\operatorname{curl} \va{F}(x, y)$. A nabla notation also exists for curl, which will be discussed later.
Since we are considering 2D space, curl behaves a bit differerently, hence we shall use a different notation: $\operatorname{curl}_z \va{F}(x, y)$.

Decompose the vector field into components:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Consider the case where the curl is positive. This means that the water is rotating counterclockwise. Draw a point and some vectors around it:

<Mafs>
    <Point x={0} y={0} />
    <Vector tail={[-1, 0]} tip={[-1, -1]} />
    <Vector tail={[0, 1]} tip={[-1, 1]} />
    <Vector tail={[1, 0]} tip={[1, 1]} />
    <Vector tail={[0, -1]} tip={[1, -1]} />
</Mafs>

Label the signs of the vectors:

<Mafs>
    <Point x={0} y={0} />

    <Vector tail={[-1, 0]} tip={[-1, -1]} />
    <LaTeX tex={"Q < 0"} at={lineLabel([-1, 0], [-1, -1], "right", { sideOffset: 0.6 })} />

    <Vector tail={[0, 1]} tip={[-1, 1]} />
    <LaTeX tex={"P < 0"} at={lineLabel([0, 1], [-1, 1], "right", { sideOffset: 0.3 })} />

    <Vector tail={[1, 0]} tip={[1, 1]} />
    <LaTeX tex={"Q > 0"} at={lineLabel([1, 0], [1, 1], "right", { sideOffset: 0.6 })} />

    <Vector tail={[0, -1]} tip={[1, -1]} />
    <LaTeX tex={"P > 0"} at={lineLabel([0, -1], [1, -1], "right", { sideOffset: 0.3 })} />
</Mafs>

Hence, notice that the curl is positive when $P$ is decreasing in the $y$ direction and $Q$ is increasing in the $x$ direction.

Combining the two components, the curl is defined as:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y} \label{eq:formulation_of_curl_in_2d}
\end{equation}
$$

This also means that $P$ does not necessarily have to go from positive to negative, and $Q$ does not necessarily have to go from negative to positive.
In other words, both of these situations contribute the same to the curl:

<Mafs>
    <Transform translate={[-3, 0]}>
        <Vector tail={[-1, 0]} tip={[-1, -1]} />
        <Vector tail={[1, 0]} tip={[1, 1]} />
        <Point x={0} y={0} />
    </Transform>
    <Transform translate={[3, 0]}>
        <Vector tail={[-1, 0]} tip={[-1, 1]} />
        <Vector tail={[1, 0]} tip={[1, 2]} />
        <Point x={0} y={0} />
    </Transform>
</Mafs>

### Example Problem: Evaluating Curl

> The vector field $\va{v}(x, y)$ is given by:
>
> $$
> \begin{equation}
> \va{v}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x]
> \end{equation}
> $$
>
> Evaluate the curl of $\va{v}(x, y)$.

To evaluate the curl, we need to find the partial derivatives of the components of the vector field.
Define the components of the vector field:

$$
\begin{equation}
\va{v}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x] = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Then, find the partial derivatives:

$$
\begin{align}
\pdv{P}{y} &= \pdv{}{y} (y^3 - 9y) = 3y^2 - 9 \\
\pdv{Q}{x} &= \pdv{}{x} (x^3 - 9x) = 3x^2 - 9
\end{align}
$$

Finally, evaluate the curl:

$$
\begin{equation}
\operatorname{curl}_z \va{v}(x, y) = \pdv{Q}{x} - \pdv{P}{y} = 3x^2 - 9 - (3y^2 - 9) = 3x^2 - 3y^2
\end{equation}
$$

Hence, the curl of $\va{v}(x, y)$ is $3x^2 - 3y^2$.

### Three-Dimensional Rotation Vectors

Curl is related to rotation, so it's natural to consider how rotation works in 3D space before discussing the general formula for curl.

First consider 2D rotation. It can be described by a measure of the rotation speed, like 45 degrees per second.
For the direction, it depends on the sign of the rotation. Conventionally a positive rotation is counterclockwise.
Notice how, just with one number, we can describe 2D rotation in its entirety.

In 3D space, rotation is more complex:

1. First we need to consider the axis of rotation. This is where the rotation occurs about.
2. Next, we need to consider the magnitude and direction of the rotation - which is a vector. This is known as the **angular velocity**, denoted $\va{\omega}$.

<CustomMathbox>
    <MB.Cartesian>
        <MB.Matrix
            id="sphere"
            bufferWidth={128}
            bufferHeight={64}
            width={65}
            height={32}
            expr={(emit, i, j, time) => {
                let phi = (i / 64) * Math.PI * 2;
                let theta = (j / 31 - 0.5) * Math.PI;

                // rotate the sphere by w * time
                let w = 0.5;
                let x = Math.cos(phi) * Math.cos(theta);
                let y = Math.sin(theta);
                let z = Math.sin(phi) * Math.cos(theta);

                let x1 = x * Math.cos(w * time) - z * Math.sin(w * time);
                let z1 = x * Math.sin(w * time) + z * Math.cos(w * time);

                emit(
                    x1 / 2,
                    y / 2,
                    z1 / 2
                );
            }}
            channels={3}
        />
        <MB.Surface
            points="#sphere"
            color={"#B0B0B0"}
            lineX={true}
            lineY={true}
            opacity={0.75}
            zBias={-1}
        />

        <MB.Array
            items={2}
            id="rot1_vec"
            data={[
                [0, 0.5, 0],
                [0, 0.8, 0]
            ]}
            channels={3}
        />
        <MB.Vector end={true} points="#rot1_vec" color={color("blue")} />
        <MB.Array
            items={2}
            id="rot2_vec"
            data={[
                [0, -0.5, 0],
                [0, -0.8, 0]
            ]}
            channels={3}
        />
        <MB.Vector end={true} points="#rot2_vec" color={color("green")} />
    </MB.Cartesian>
</CustomMathbox>

The convention for the direction of the angular velocity vector is called the **right-hand rule**.
Take your right hand and curl your fingers in the direction of the rotation. Your thumb then points in the direction of the angular velocity vector.
Hence, in a single vector we can describe the axis of rotation, the direction of rotation, and the speed of rotation.

### Intuituion for Curl in 3D

Take the vector field $\va{F}$ defined previously as:

$$
\begin{equation}
\va{F}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x]
\end{equation}
$$

We have previously plotted the vector field in 2D space. Now, consider putting the same vector field in 3D space, on the $xy$ plane:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Area
            id="vector_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                // original point
                emit(x, 0, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.5);
                emit (
                    x + normalized[0],
                    0,
                    y + normalized[1],
                );
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Area
            id="vector_field_colors"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const mag = vec.mag(f);

                const [r, g, b] = getColorFromMagnitude(mag, 0, 20);
                emit(r, g, b, 1.0);
            }}
            width={20}
            height={20}
            channels={4}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            colors="#vector_field_colors"
            width={5}
            end={true}
        />
    </MB.Cartesian>
</CustomMathbox>

Next, consider the 2D curl of this vector field. Recall that the curl is defined as:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y}
\end{equation}
$$

The direction of the curl shall then be in the $z$ direction, defined via the right-hand rule. With this, we can plot some vectors representing the curl alongside the vector field:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Area
            id="vector_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                // original point
                emit(x, 0, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.5);
                emit(
                    x + normalized[0],
                    0,
                    y + normalized[1]
                );
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            color={color("yellow")}
            width={5}
            end={true}
        />

        <MB.Area
            id="curl_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const curlz = 3 * x ** 2 - 3 * y ** 2;
                emit(x, 0, y);
                emit(x, curlz / 75, y);
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#curl_field"
            width={5}
            end={true}
            color={color("blue")}
        />
    </MB.Cartesian>
</CustomMathbox>

Notice that in areas of clockwise rotation, the curl is negative (points in the $-z$ direction), and in areas of counterclockwise rotation, the curl is positive (points in the $z$ direction).

The curl is a vector that purely exists in the $z$ direction. Hence, a prototype for the 3D curl could be, for a vector field $\va{F} = \mqty[P \\ Q]$:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{equation}
$$

However this does not fully capture the curl, since it only works on a 2D vector field.
To generalize this more, we need to do this for a vector field in 3D space. Recall our original vector field $\va{F}$:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)] = \mqty[y^3 - 9y \\ x^3 - 9x]
\end{equation}
$$

This results, as we've seen, in a vector field that lies on a plane.
Consider "copying" this vector for every $z$ value:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Volume
            id="vector_field"
            expr={(emit, y, z, x, i, t) => {
                // original point
                emit(x, z, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.75);
                emit(
                    x + normalized[0],
                    z,
                    y + normalized[1]
                );
            }}
            items={2}
            width={10}
            height={10}
            depth={10}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
            rangeZ={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            color={color("yellow")}
            width={3}
            end={true}
        />
    </MB.Cartesian>
</CustomMathbox>

Of course, only some of the vectors are visible. In reality, for every $z$ value, there is a plane in which the vector field exists.
Thus, the vector field can be thought of as a volume in 3D space:

$$
\begin{equation}
\va{F}(x, y\class{green}{, z}) = \mqty[P(x, y\class{green}{, z}) \\ Q(x, y\class{green}{, z}) \\ \class{green}{0}] = \mqty[y^3 - 9y \\ x^3 - 9x \\ 0]
\end{equation}
$$

We have:

1. Added a third input to the vector field, $z$. Notice that the output does not depend on $z$, which reflects the fact that the vector field does not change with $z$ (i.e. are copies of each other).
2. Added a third component to the vector field, which is always zero. This reflects how the vectors are all "flat".

Next, just like before, we can add the curl vectors to the vector field. Since the vector field is unchanging in the $z$ direction, the curl will also be unchanging in the $z$ direction.
This means that if you take a column somewhere in the vector field, the curl will be the same for all the vectors in that column.

{(() => {
    const [fieldVisible, setFieldVisible] = useState(true);
    const [curlVisible, setCurlVisible] = useState(true);
    return (
        <div className="card">
            <div className="card__body">
                <CustomMathbox>
                    <MB.Cartesian
                        scale={[
                            0.3, 0.3, 0.3
                        ]}
                    >
                        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
                        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
                        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
                        <MB.Group visible={fieldVisible}>
                            <MB.Volume
                                id="vector_field"
                                expr={(emit, y, z, x, i, t) => {
                                    // original point
                                    emit(x, z, y);
                                    const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                                    const normalized = vec.withMag(f, 0.75);
                                    emit(
                                        x + normalized[0],
                                        z,
                                        y + normalized[1]
                                    );
                                }}
                                items={2}
                                width={10}
                                height={10}
                                depth={10}
                                channels={3}
                                rangeX={[-4, 4]}
                                rangeY={[-4, 4]}
                                rangeZ={[-4, 4]}
                            />
                            <MB.Vector
                                points="#vector_field"
                                color={color("yellow")}
                                width={3}
                                end={true}
                            />
                        </MB.Group>
                        <MB.Group visible={curlVisible}>
                            <MB.Volume
                                id="curl_field"
                                expr={(emit, y, z, x, i, t) => {
                                    const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                                    const curlz = 3 * x ** 2 - 3 * y ** 2;
                                    emit(x, z, y);
                                    emit(x, z + curlz / 75, y);
                                }}
                                items={2}
                                width={10}
                                height={10}
                                depth={10}
                                channels={3}
                                rangeX={[-4, 4]}
                                rangeY={[-4, 4]}
                                rangeZ={[-4, 4]}
                            />
                            <MB.Vector
                                points="#curl_field"
                                width={3}
                                end={true}
                                color={color("blue")}
                            />
                        </MB.Group>
                    </MB.Cartesian>
                </CustomMathbox>
            </div>
            <div className="card__footer">
                <button onClick={() => setFieldVisible(!fieldVisible)} className={`button button--block ${fieldVisible ? "button--primary" : "button--secondary"}`}>
                    {fieldVisible ? "Hide" : "Show"} Vector Field
                </button>
                <button onClick={() => setCurlVisible(!curlVisible)} className={`button button--block ${curlVisible ? "button--primary" : "button--secondary"}`}>
                    {curlVisible ? "Hide" : "Show"} Curl
                </button>
            </div>
        </div>
    );
})()}

Recall our prototype for the 3D curl:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}] = \mqty[0 \\ 0 \\ 3x^2 - 3y^2]
\end{equation}
$$

We can adjust this to include $z$ as an input:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y, z) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}] = \mqty[0 \\ 0 \\ 3x^2 - 3y^2]
\end{equation}
$$

We're not done yet. Recall that $\va{F}$ is defined such that it is constant in the $z$ direction.
For vector fields that are *not* constant in the $z$ direction, the curl will be different.

The problem with 3D vector fields is that it is difficult to visualize the direction of rotation.
One way to think about it is to consider hovering a ball in the vector field, and letting the fluid flow around it, causing it to rotate.

### Formulation of Curl in 3D

To formulate the curl in 3D, consider a vector field $\va{F}$:

$$
\begin{equation}
\va{F}(x, y, z) = \mqty[P(x, y, z) \\ Q(x, y, z) \\ R(x, y, z)]
\end{equation}
$$

Since curl has a direction, we expect the curl to output some 3D vector as well.
This formula is usually written in terms of the nabla operator:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y, z) = \curl \va{F}(x, y, z)
\end{equation}
$$

Where the nabla operator is defined as $\grad = \mqty[\pdv{x} \\ \pdv{y} \\ \pdv{z}]$.
Recall the 2D curl formula from Equation $\eqref{eq:formulation_of_curl_in_2d}$:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y}
\end{equation}
$$

We can take our 3D curl formula and treat it as a generalization of the 2D curl formula. Then, the curl in 2D is defined as a special case:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \curl \va{F}(x, y) = \mqty[\pdv{x} \\ \pdv{y}] \times \mqty[P(x, y) \\ Q(x, y)] = \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{equation}
$$

This aligns with our previous definition of curl in 2D in Equation $\eqref{eq:formulation_of_curl_in_2d}$.

For a 3D vector field, recall that the cross product can be defined as the determinant of a certain matrix:

$$
\begin{equation}
\va{A} \times \va{B} = \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ A_x & A_y & A_z \\ B_x & B_y & B_z]
\end{equation}
$$

So, the curl of a 3D vector field is hence defined as:

$$
\begin{equation}
\begin{split}
\operatorname{curl} \va{F}(x, y, z) &= \class{yellow}{\nabla} \times \class{green}{\va{F}(x, y, z)} \\
&= \class{yellow}{\mqty[\pdv{x} \\ \pdv{y} \\ \pdv{z}]} \times \class{green}{\mqty[P(x, y, z) \\ Q(x, y, z) \\ R(x, y, z)]} \\
&= \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ \class{yellow}{\pdv{x}} & \class{yellow}{\pdv{y}} & \class{yellow}{\pdv{z}} \\ \class{green}{P} & \class{green}{Q} & \class{green}{R}]
\end{split}
\end{equation}
$$

This is an absurd notational trick. We have a matrix of:

- The unit vectors $\vu{i}$, $\vu{j}$, and $\vu{k}$. Matrices should not have vectors as elements.
- Partial differential operators.
- The components of the vector field, which are all multivariable functions.

To compute the determinant, we:

1. First take $\vu{i}$ and the submatrix formed by removing the row and column of $\vu{i}$.
2. Multiply $\vu{i}$ by the determinant of this submatrix.
3. Repeat this for $\vu{j}$ and $\vu{k}$.

This results in:

$$
\begin{equation}
\begin{split}
\operatorname{curl} \va{F}(x, y, z) &= \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ \pdv{x} & \pdv{y} & \pdv{z} \\ P & Q & R] \\
&= \vu{i}\qty(\pdv{Q}{z} - \pdv{R}{y}) - \vu{j}\qty(\pdv{P}{z} - \pdv{R}{x}) + \vu{k}\qty(\pdv{P}{y} - \pdv{Q}{x}) \\
&= \mqty[\pdv{R}{y} - \pdv{Q}{z} \\ \pdv{P}{z} - \pdv{R}{x} \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{split}
\end{equation}
$$

Notice the third term $\vu{k}\qty(\pdv{P}{y} - \pdv{Q}{x})$. This is the same as the 2D curl formula, with $k$ added to it.
This should make conceptual sense.

### The Third Maxwell Equation: Faraday's Law

Faraday's law is one of the four Maxwell equations, which describe how a changing magnetic field induces an electric field.
It is given by:

$$
\begin{equation}
\curl \class{yellow}{\va{E}} = -\pdv{\class{blue}{\va{B}}}{t}
\end{equation}
$$

Where $\class{yellow}{\va{E}}$ is the electric field and $\class{blue}{\va{B}}$ is the magnetic field.
We can dissect this equation and intuitively understand it.

Consider a magnet on a table. The magnet creates a magnetic field around it, and this field changes when the magnet is moved.

{(() => {
    const magPoint = useMovablePoint([0, 0], {
        constrain: ([x, y]) => [x, 0],
    });
    return (
        <Mafs>
            <Line.PointSlope point={[0, -0.5]} slope={0} /> {/* table */}
            <Transform translate={magPoint.point}>
                <Polygon
                    points={[
                        [0, -0.5],
                        [0, 0.5],
                        [2, 0.5],
                        [2, -0.5],
                    ]}
                    color={color("red")}
                />
                <Text x={0.5} y={0}>N</Text>

                <Polygon
                    points={[
                        [2, -0.5],
                        [2, 0.5],
                        [4, 0.5],
                        [4, -0.5],
                    ]}
                    color={color("blue")}
                />
                <Text x={3.5} y={0}>S</Text>
            </Transform>
            {magPoint.element}
        </Mafs>
    );
})()}

## Interpretations of Divergence and Curl with its Formulas

An interesting way to think about divergence and curl is to consider the formulas for each:

$$
\begin{align}
\operatorname{div} \va{F}(x, y, z) &= \div \va{F}(x, y, z) \\
\operatorname{curl} \va{F}(x, y, z) &= \curl \va{F}(x, y, z)
\end{align}
$$

Recall the geometric properties of the dot and cross products:

- The dot product is the highest when the two vectors are in the same direction.
- The cross product is the highest when the two vectors are perpendicular.

Recall that the gradient describes how a function changes in space. Consider a point in space, and a step in the $x$ direction.
Draw a vector for both points:

<Mafs>
    <Transform translate={[-0.5, 0]}>
        <Point x={0} y={0} />
        <LaTeX tex="\vec{\mathbf{r}}" at={[0, -0.5]} />
        <Vector tip={[0, 1]} />
    </Transform>
    <Vector tail={[-0.5, 0]} tip={[0.5, 0]} />
    <Transform translate={[0.5, 0]}>
        <Point x={0} y={0} />
        <LaTeX tex="\vec{\mathbf{r}} + \Delta \vec{\mathbf{r}}" at={[0, -0.5]} />
        <Vector tip={[0.5, 1]} />
    </Transform>
</Mafs>

Consider the difference between the two vectors. In some sense, this represents how the vector field changes with the step.
As the divergence increases, then the direction of this difference should be in the direction of the step itself; an outward step should result in an outward difference.

Next, recall that the dot product is the highest when the two vectors are in the same direction.
Hence, the dot product of the gradient and the vector field should be the highest when the gradient is in the direction of the vector field.
This is the case when the divergence is positive.

<Mafs>
    <Point x={0} y={0} />
    {range(0, 2 * Math.PI, Math.PI / 4).map((angle) => (
        <Fragment key={angle}>
            <Vector
                tail={[0, 0]}
                tip={[Math.cos(angle), Math.sin(angle)]}
            />
            <Vector
                tail={[Math.cos(angle), Math.sin(angle)]}
                tip={[1.5 * Math.cos(angle), 1.5 * Math.sin(angle)]}
                color={color("red")}
            />
        </Fragment>
    ))}
    <LaTeX
        tex="\htmlClass{red}{\text{(change in output)}} \cdot \text{(step)}"
        at={[0, -2]}
        katexOptions={{
            // allow html tags
            trust: (context) => context.command === "\\htmlClass",
            strict: false,
        }}
    />
</Mafs>

Compare this to the curl. The cross product is the highest when the two vectors are perpendicular.
As such, the curl should be the highest when the gradient is perpendicular to the vector field.

<Mafs>
    <Point x={0} y={0} />
    {range(0, 2 * Math.PI, Math.PI / 4).map((angle) => (
        <Fragment key={angle}>
            <Vector
                tail={[0, 0]}
                tip={[Math.cos(angle), Math.sin(angle)]}
            />
            <Vector
                tail={[Math.cos(angle), Math.sin(angle)]}
                tip={[
                    // rotate by 90 degrees
                    Math.cos(angle) + Math.sin(angle),
                    Math.sin(angle) - Math.cos(angle),
                ]}
                color={color("red")}
            />
        </Fragment>
    ))}
    <LaTeX
        tex="\htmlClass{red}{\text{(change in output)}} \times \text{(step)}"
        at={[0, -2]}
        katexOptions={{
            // allow html tags
            trust: (context) => context.command === "\\htmlClass",
            strict: false,
        }}
    />
</Mafs>

This is why the curl is highest when the vector field is rotating the fastest.

## Laplacian of a Scalar Field

The Laplacian is another operator for vector fields. It gives a scalar field as an output, and can be thought of as the multivariable generalization of the second derivative.
Essentially you add up the second partial derivatives of the components of the scalar field:

$$
\begin{equation}
\operatorname{Lap} f(x, y, z) = \pdv[2]{f}{x} + \pdv[2]{f}{y} + \pdv[2]{f}{z}
\end{equation}
$$

We can generalize this to any vector space with basis vectors $\vu{e}_i$:

$$
\begin{equation}
\operatorname{Lap} f(x, y, z) = \sum_i \pdv[2]{f_i}{x_i}
\end{equation}
$$

An alternate notation for the Laplacian exists.
The Laplacian can be written as the derivative of the first derivative of the vector field:

$$
\begin{equation}
\begin{split}
\operatorname{Lap} f(x, y, z) &= \pdv{x} \pdv{f}{x} + \pdv{y} \pdv{f}{y} + \pdv{z} \pdv{f}{z} \\
&= \operatorname{div} \grad{f(x, y, z)}
\end{split}
\end{equation}
$$

Hence:

$$
\begin{equation}
\operatorname{Lap} \va{F}(x, y) = \operatorname{div} (\operatorname{grad} \va{F}(x, y))
\end{equation}
$$

Alternatively, we can use the nabla notation:

$$
\begin{equation}
\operatorname{Lap} \va{F}(x, y) = \div{\grad{\va{F}(x, y)}} = \laplacian{\va{F}(x, y)}
\end{equation}
$$

Sometimes it is also written using the $\Delta$ symbol:

$$
\begin{equation}
\Delta \va{F}(x, y) = \laplacian \va{F}(x, y)
\end{equation}
$$

### Intuition for Laplacian

Recall that the divergence is a measure of how much a vector field is expanding or contracting.
To illustrate how the Laplacian works, first consider a scalar-valued function $f(x, y)$:

$$
\begin{equation}
f(x, y) = \sin(x) \cos(y) + 3
\end{equation}
$$

We can plot this function as a surface in 3D space:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.1, 0.1, 0.1
        ]}
    >
        <MB.Axis axis="x" range={[-10, 10]} color={color("blue")} />
        <MB.Axis axis="y" range={[-10, 10]} color={color("green")} />
        <MB.Axis axis="z" range={[-10, 10]} color={color("yellow")} />
        <MB.Area
            id="graph"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const z = Math.sin(x) * Math.cos(y) + 3;
                emit(x, z, y);
            }}
            width={64}
            height={64}
            channels={3}
            rangeX={[-10, 10]}
            rangeY={[-10, 10]}
        />
        <MB.Surface
            points="#graph"
            color={"#B0B0B0"}
            lineX={true}
            lineY={true}
            opacity={0.75}
            zBias={-1}
        />
    </MB.Cartesian>
</CustomMathbox>

First, we can plot the gradient as a vector field. The gradient points in the direction of the steepest ascent of the function:

{(() => {
    const [surfaceVisible, setSurfaceVisible] = useState(true);
    const [fieldVisible, setFieldVisible] = useState(true);
    return (
        <div className="card">
            <div className="card__body">
                <CustomMathbox>
                    <MB.Cartesian
                        scale={[
                            0.1, 0.1, 0.1
                        ]}
                    >
                        <MB.Axis axis="x" range={[-10, 10]} color={color("blue")} />
                        <MB.Axis axis="y" range={[-10, 10]} color={color("green")} />
                        <MB.Axis axis="z" range={[-10, 10]} color={color("yellow")} />
                        <MB.Group visible={surfaceVisible}>
                            <MB.Area
                                id="graph"
                                axes="xy"
                                expr={(emit, y, x, i, t) => {
                                    const z = Math.sin(x) * Math.cos(y) + 3;
                                    emit(x, z, y);
                                }}
                                width={64}
                                height={64}
                                channels={3}
                                rangeX={[-10, 10]}
                                rangeY={[-10, 10]}
                            />
                            <MB.Surface
                                points="#graph"
                                color={"#B0B0B0"}
                                lineX={true}
                                lineY={true}
                                opacity={0.75}
                                zBias={-1}
                            />
                        </MB.Group>
                        <MB.Group visible={fieldVisible}>
                            <MB.Area
                                id="gradient_field"
                                axes="xy"
                                expr={(emit, y, x, i, t) => {
                                    // the original point
                                    emit(x, 0, y);
                                    // gradient
                                    const gradient = [Math.cos(x) * Math.cos(y), -Math.sin(x) * Math.sin(y)];
                                    const normalized = vec.normalize(gradient);
                                    emit(x + normalized[0], 0, y + normalized[1]);
                                }}
                                items={2}
                                width={20}
                                height={20}
                                channels={3}
                                rangeX={[-10, 10]}
                                rangeY={[-10, 10]}
                            />
                            <MB.Area
                                id="gradient_field_colors"
                                axes="xy"
                                expr={(emit, y, x, i, t) => {
                                    const gradient = [Math.cos(x) * Math.cos(y), -Math.sin(x) * Math.sin(y)];
                                    const mag = vec.mag(gradient);
                                    const [r, g, b] = getColorFromMagnitude(mag, 0, 1);
                                    emit(r, g, b, 1.0);
                                }}
                                width={20}
                                height={20}
                                channels={4}
                                rangeX={[-10, 10]}
                            />
                            <MB.Vector
                                points="#gradient_field"
                                colors="#gradient_field_colors"
                                width={5}
                                end={true}
                            />
                        </MB.Group>
                    </MB.Cartesian>
                </CustomMathbox>
            </div>
            <div className="card__footer">
                <button onClick={() => setSurfaceVisible(!surfaceVisible)} className={`button button--block ${surfaceVisible ? "button--primary" : "button--secondary"}`}>
                    {surfaceVisible ? "Hide" : "Show"} Surface
                </button>
                <button onClick={() => setFieldVisible(!fieldVisible)} className={`button button--block ${fieldVisible ? "button--primary" : "button--secondary"}`}>
                    {fieldVisible ? "Hide" : "Show"} Gradient Field
                </button>
            </div>
        </div>
    )
})()}

Imagine this surface as some sort of mountain. The gradient points in the direction where you would walk to ascend the mountain the fastest.

At some peak of the mountain, the gradient in the points around it would point towards the peak, since that is the steepest ascent.
On the other hand, at the "bottom" of the mountain, the gradient would point away from the peak, since that is the steepest descent.

We can view the Laplacian as the divergence of this gradient field. Then:

1. At the peak, the gradient points towards the peak, and the divergence is positive. So the Laplacian is positive.
2. At the bottom, the gradient points away from the peak, and the divergence is negative. So the Laplacian is negative.

This is similar to how the second derivative works for single-variable functions:

1. At a peak, the second derivative is positive, and the function is concave up. This is also called a "local minimum".
2. At a bottom, the second derivative is negative, and the function is concave down. This is also called a "local maximum".

### Example Problem: Laplacian of a Scalar Field

> Evaluate the Laplacian for the following scalar field:
>
> $$
> \begin{equation}
> f(x, y) = (x + y)^2 + \sin(x)\cos(y)
> \end{equation}
> $$

Recall the Laplacian formula:

$$
\begin{equation}
\operatorname{Lap} \va{F}(x, y) = \operatorname{div} (\operatorname{grad} \va{F}(x, y)) = \div{\grad{f(x, y)}}
\end{equation}
$$

First, we need to find the gradient of the scalar field, which is a vector of its partial derivatives:

$$
\begin{equation}
\grad{f(x, y)} = \mqty[\pdv{f}{x} \\ \pdv{f}{y}] = \mqty[2(x + y) + \cos(x)\cos(y) \\ 2(x + y) - \sin(x)\sin(y)]
\end{equation}
$$

Next, we need to find the divergence of the gradient:

$$
\begin{equation}
\begin{split}
\div{\grad{f(x, y)}} &= \pdv{x} \qty(2(x + y) + \cos(x)\cos(y)) + \pdv{y} \qty(2(x + y) - \sin(x)\sin(y)) \\
&= 2 - \sin(x)\cos(y) + 2 - \sin(x)\cos(y) \\
&= 4 - 2\sin(x)\cos(y)
\end{split}
\end{equation}
$$

Hence, the Laplacian of the scalar field is:

$$
\begin{equation}
\operatorname{Lap} f(x, y) = 4 - 2\sin(x)\cos(y)
\end{equation}
$$

## Harmonic Functions

Harmonic functions are a special class of functions that satisfy something known as the Laplace equation.
It is defined based on the Laplacian of a scalar field:

$$
\begin{equation}
\laplacian{f(x, y)} \equiv 0
\end{equation}
$$

Since the Laplacian is the multivariable generalization of the second derivative, we can understand this by first taking a single-variable case:

$$
\begin{equation}
\dv[2]{f}{x} = 0
\end{equation}
$$

If we integrate this twice, we get:

$$
\begin{align}
\dv{f}{x} &= \int 0 \dd{x} = m \\
f(x) &= \int m \dd{x} = mx + c
\end{align}
$$

Meaning it is a straight line.
This should also make sense intuitively; a zero second derivative means that the slope is constant throughout the function, so the function should never curve.

Consider the following scalar field:

$$
\begin{equation}
f(x, y) = e^x \sin(y)
\end{equation}
$$

With a constant $y$ value, the function is simply an exponential, and with a nonconstant $y$ value, the function is an exponential that sort of oscillates.

Consider the Laplacion of this scalar field:

$$
\begin{equation}
\begin{split}
\laplacian{f(x, y)} &= \pdv[2]{f}{x} + \pdv[2]{f}{y} \\
&= \pdv{x} \qty(\pdv{f}{x}) + \pdv{y} \qty(\pdv{f}{y}) \\
&= \pdv{x} \qty(e^x \sin(y)) + \pdv{y} \qty(e^x \cos(y)) \\
&= e^x \sin(y) - e^x \sin(y) = 0
\end{split}
\end{equation}
$$

If we plot the scalar field $f(x, y) = e^x \sin(y)$, it doesn't look like a straight line, but it is a harmonic function:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.1, 0.1, 0.1
        ]}
    >
        <MB.Axis axis="x" range={[-10, 10]} color={color("blue")} />
        <MB.Axis axis="y" range={[-10, 10]} color={color("green")} />
        <MB.Axis axis="z" range={[-10, 10]} color={color("yellow")} />
        <MB.Area
            id="graph"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const z = Math.exp(x) * Math.sin(y);
                emit(x, z, y);
            }}
            width={64}
            height={64}
            channels={3}
            rangeX={[-10, 10]}
            rangeY={[-10, 10]}
        />
        <MB.Surface
            points="#graph"
            color={"#B0B0B0"}
            lineX={true}
            lineY={true}
            opacity={0.75}
            zBias={-1}
        />
    </MB.Cartesian>
</CustomMathbox>

To show why this is harmonic, consider the single-variable case again:

In a point where $\dv[2]{f}{x} > 0$, the function is concave up. This means that the points around it are higher than the point itself.
Even in a situation where the function has a positive slope:

<Mafs
    viewBox={{
        x: [0, 4],
        y: [-1, 2]
    }}
>
    <Coordinates.Cartesian />
    <Plot.OfX y={(x) => x ** 2 / 5} />
    <Point x={2} y={4 / 5} color={color("red")} />
    <Point x={1} y={1 / 5} />
    <Point x={3} y={9 / 5} />
</Mafs>

While there are points that are lower than the point itself, *on average*, the points around it are higher.

Next, generalize this to a scalar field. If the Laplacian is nonzero, then it means that around the point, its neighbors are higher/lower than the point itself on average:

1. If the Laplacian is positive ($\laplacian{f(x, y)} > 0$), then the neighbors are higher than the point itself on average.
2. If the Laplacian is negative ($\laplacian{f(x, y)} < 0$), then the neighbors are lower than the point itself on average.

The function we have is harmonic; the Laplacian is zero. This means that **on average, the point's neighbors are at the same height as the point itself**.

Laplacians come up in many areas of physics, and this concept of the neighbors' height does have physical significance.
For example, if you were considering heat flow, then you would consider the heat around the point to evaluate how the heat is distributed.
If the temperature around is higher than the point, then the point will heat up, and vice versa.
This can be written as a proportional relationship. Denoting $T(\va{r}, t)$ as the temperature at a point $\va{r}$ at time $t$, then:

$$
\begin{equation}
\pdv{T}{t}(\va{r}, t) = k \laplacian{T(\va{r}, t)}
\end{equation}
$$

The word equation for that is as follows:

$$
\begin{equation}
\text{Temperature change at point} \propto \text{How much temperature around it is different}
\end{equation}
$$

This is also known as the **heat equation**.

## Jacobian and Local Linearity

The Jacobian is another operator for vector fields.

Recall from linear algebra that a matrix can be used to represent a linear transformation.
Each column decides where the basis vectors go, and the matrix is hence the result of applying the transformation to the basis vectors.

The Jacobian is a generalization of this concept to multivariable functions.

First, consider a vector field $\va{F}(x, y)$:

$$
\begin{equation}
\va{F}(x, y) = \mqty[x + \sin(y) \\ y + \sin(x)]
\end{equation}
$$

This is not a linear transformation. It does not satisfy the properties of a linear transformation, like additivity and homogeneity.
We can view this transformation on a grid:

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
/>

Using the visualization, we can also tell that it is not a linear transformation:

1. The grid lines are not straight after the transformation.
2. The grid lines are not parallel and evenly spaced after the transformation.

This function has a special property known as **local linearity**. Consider a region in the same vector field at a point $(x_0, y_0)$ and zoom in:

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
    xGridRange={[...range(-10, 11, 1), ...range(-2.3, -1.6, 0.1)]}
    yGridRange={[...range(-10, 11, 1), ...range(0.7, 1.4, 0.1)]}
    lerpedItems={(lerpedFn) => {
        const point = lerpedFn(-2, 1);
        return (
            <Circle center={point} radius={0.5} />
        )
    }}
/>

Around this point, notice that while the lines still curve a bit, it is *almost* a linear transformation.
We can do even better by zooming in further:

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
    xGridRange={[...range(-10, 11, 1), ...range(-2.1, -1.9, 0.05)]}
    yGridRange={[...range(-10, 11, 1), ...range(0.9, 1.1, 0.05)]}
    lerpedItems={(lerpedFn) => {
        const point = lerpedFn(-2, 1);
        return (
            <Circle center={point} radius={0.25} />
        )
    }}
    mafsProps={{
        viewBox: {
            x: [-3, 0],
            y: [-1, 2]
        }
    }}
/>

The question is, if the function approaches a linear transformation as we zoom in, what is this linear transformation?

### The Jacobian Matrix

Consider a small step in the $x$ direction at the point $(x_0, y_0)$.
This corresponds to some small step in the output vector field after the transformation.

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
    xGridRange={[...range(-10, 11, 1), ...range(-2.1, -1.9, 0.05)]}
    yGridRange={[...range(-10, 11, 1), ...range(0.9, 1.1, 0.05)]}
    lerpedItems={(lerpedFn) => {
        const point1 = lerpedFn(-2, 1);
        const point2 = lerpedFn(-2 + 0.15, 1);
        const point2middle = [point2[0], point1[1]];
        return (
            <>
                <Circle center={point1} radius={0.25} />
                <Line.Segment point1={point1} point2={point2middle} />
                <Line.Segment point1={point2} point2={point2middle} />
                <Vector tail={point1} tip={point2} color={color("red")} />
            </>
        )
    }}
    mafsProps={{
        viewBox: {
            x: [-2, -1],
            y: [0, 1]
        }
    }}
/>

Treat the individual components of the vector field as functions:

$$
\begin{equation}
\va{F}(x, y) = \mqty[x + \sin(y) \\ y + \sin(x)] = \mqty[f_1(x, y) \\ f_2(x, y)]
\end{equation}
$$

Looking at the visualization above, we can see that the step in the output vector field can be expressed as the sum of the steps in the individual components.

Denote the change in $x$ as $\partial x$ and the change in the vector field as $\partial \va{F}$.
We can write that $\partial \va{F}$ is the sum of the changes in the individual components:

$$
\begin{equation}
\partial \va{F} = \mqty[\partial f_1 \\ \partial f_2]
\end{equation}
$$

Then, the change in the vector field with respect to the change in $x$ is:

$$
\begin{equation}
\pdv{\va{F}}{x} = \mqty[\pdv{f_1}{x} \\ \pdv{f_2}{x}]
\end{equation}
$$

We can do the same for the change in $y$:

$$
\begin{equation}
\pdv{\va{F}}{y} = \mqty[\pdv{f_1}{y} \\ \pdv{f_2}{y}]
\end{equation}
$$

This represents the change in the vector field with respect to the change in $y$:

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
    xGridRange={[...range(-10, 11, 1), ...range(-2.1, -1.9, 0.05)]}
    yGridRange={[...range(-10, 11, 1), ...range(0.9, 1.1, 0.05)]}
    lerpedItems={(lerpedFn) => {
        const point1 = lerpedFn(-2, 1);
        const point2 = lerpedFn(-2, 1 + 0.15);
        const point2middle = [point2[0], point1[1]];
        return (
            <>
                <Circle center={point1} radius={0.25} />
                <Line.Segment point1={point1} point2={point2middle} />
                <Line.Segment point1={point2} point2={point2middle} />
                <Vector tail={point1} tip={point2} color={color("red")} />
            </>
        )
    }}
    mafsProps={{
        viewBox: {
            x: [-2, -1],
            y: [0, 1]
        }
    }}
/>

Combining the vectors of the changes in the vector field with respect to $x$ and $y$, we get:

$$
\mqty[\pdv{f_1}{x} & \pdv{f_1}{y} \\ \pdv{f_2}{x} & \pdv{f_2}{y}]
$$

This represents the linear transformation of the vector field around the point $(x_0, y_0)$, and is known as the **Jacobian matrix**.

This is very similar to how linear approximation works for single-variable functions.
For a single-variable function $f(x)$, if we zoom in around a point $x_0$, then the function can be approximated as a line.
Then the slope of that line (the transformation) can be found by taking a small step in $x$.

The Jacobian can be denoted as $\va{J}_{\va{F}}$. Then, the Jacobian matrix can be generalized to any dimension:

$$
\begin{equation}
\va{J}_{\va{F}} = \mqty[\pdv{\va{F}}{x_1} & \pdv{\va{F}}{x_2} & \ldots & \pdv{\va{F}}{x_n}] = \mqty[\pdv{f_1}{x_1} & \pdv{f_1}{x_2} & \ldots & \pdv{f_1}{x_n} \\ \pdv{f_2}{x_1} & \pdv{f_2}{x_2} & \ldots & \pdv{f_2}{x_n} \\ \vdots & \vdots & \ddots & \vdots \\ \pdv{f_m}{x_1} & \pdv{f_m}{x_2} & \ldots & \pdv{f_m}{x_n}]
\end{equation}
$$

### Example Problem: Evaluating the Jacobian Matrix

> Evaluate the Jacobian matrix for the following vector field:
>
> $$
> \begin{equation}
> \va{F}(x, y) = \mqty[x + \sin(y) \\ y + \sin(x)]
> \end{equation}
> $$
>
> at the point $(x_0, y_0) = (-2, 1)$.

Recall the Jacobian matrix is:

$$
\begin{equation}
\mqty[\pdv{f_1}{x} & \pdv{f_1}{y} \\ \pdv{f_2}{x} & \pdv{f_2}{y}]
\end{equation}
$$

First, find the individual components of the vector field:

$$
\begin{align}
f_1(x, y) &= x + \sin(y) \\
f_2(x, y) &= y + \sin(x)
\end{align}
$$

Next, find the partial derivatives of the components:

$$
\begin{align}
\pdv{f_1}{x} &= 1 + 0 &\quad \pdv{f_1}{y} &= 0 + \cos(y) \\
\pdv{f_2}{x} &= 0 + \cos(x) &\quad \pdv{f_2}{y} &= 1 + 0
\end{align}
$$

Hence, the Jacobian matrix is:

$$
\begin{equation}
\va{J}_{\va{F}} = \mqty[\pdv{f_1}{x} & \pdv{f_1}{y} \\ \pdv{f_2}{x} & \pdv{f_2}{y}] = \mqty[1 & \cos(y) \\ \cos(x) & 1]
\end{equation}
$$

At the point $(-2, 1)$, the Jacobian matrix is then:

$$
\begin{equation}
\va{J}_{\va{F}} = \mqty[1 & \cos(1) \\ \cos(-2) & 1] = \mqty[1 & \cos(1) \\ \cos(2) & 1]
\end{equation}
$$

### The Jacobian Determinant

The Jacobian matrix is a square matrix, and hence it has a determinant.

:::info What is a Determinant?

At the time of writing, the notes for the determinant of a matrix have not been written yet.
Hence, a small introduction to the determinant is given here.

Consider performing a linear transformation on the grid.
Draw a square on the grid, and apply the transformation to it:

<LinearTransformationVisualizer
    to={{
        ihat: [3, 0],
        jhat: [2, 3]
    }}
    transformedItems={<>
        <Polygon points={[
            [0, 0],
            [1, 0],
            [1, 1],
            [0, 1]
        ]} />
    </>}
/>

The determinant measures how much the area of the square changes after the transformation.

Without going into the details, the determinant of a 2x2 matrix is given by:

$$
\begin{equation}
\det \mqty[\class{blue}{a} & \class{green}{b} \\ \class{green}{c} & \class{blue}{d}] = \class{blue}{ad} - \class{green}{bc}
\end{equation}
$$

:::

Let's go back to our example vector field. At the point $(-2, 1)$, we can draw a square around the point and apply the transformation:

<NonlinearTransformationVisualizer
    fn={(x, y) => [x + Math.sin(y), y + Math.sin(x)]}
    xGridRange={[...range(-10, 11, 1), ...range(-2.1, -1.9, 0.05)]}
    yGridRange={[...range(-10, 11, 1), ...range(0.9, 1.1, 0.05)]}
    lerpedItems={(lerpedFn) => {
        const point = lerpedFn(-2, 1);
        const squarePoints = [
            point,
            lerpedFn(-2 + 0.1, 1),
            lerpedFn(-2 + 0.1, 1 + 0.1),
            lerpedFn(-2, 1 + 0.1)
        ];
        return (
            <>
                <Circle center={point} radius={0.25} />
                <Polygon points={squarePoints} />
            </>
        )
    }}
    mafsProps={{
        viewBox: {
            x: [-2, -1],
            y: [0, 1]
        }
    }}
/>

Recall the Jacobian matrix for this vector field:

$$
\begin{equation}
\va{J}_{\va{F}} = \mqty[1 & \cos(y) \\ \cos(x) & 1]
\end{equation}
$$

Then, the Jacobian determinant is:

$$
\begin{equation}
\det \va{J}_{\va{F}} = \det \mqty[\class{blue}{1} & \class{green}{\cos(y)} \\ \class{green}{\cos(x)} & \class{blue}{1}] = \class{blue}{1} \cdot \class{blue}{1} - \class{green}{\cos(y)} \cdot \class{green}{\cos(x)} = 1 - \cos(x)\cos(y)
\end{equation}
$$

At the point $(-2, 1)$, the Jacobian determinant is then:

$$
\begin{equation}
\det \va{J}_{\va{F}} = 1 - \cos(-2)\cos(1) \approx 1.224
\end{equation}
$$

This means that the area of the square around the point $(-2, 1)$ increases by a factor of 1.224 after the transformation.

The Jacobian determinant is a useful quantity in many areas of mathematics and physics.
For example, the Jacobian determinant is used in fluid dynamics to measure how much the volume of a fluid element changes after a coordinate transformation.

## Summary

We have covered a lot of advanced topics related to multivariable derivatives in this chapter.
We have introduced these concepts:

- **Divergence**: A measure of how much a vector field is expanding or contracting.

    $$
    \begin{equation}
    \div{\va{F}(x, y)} = \pdv{F_1}{x} + \pdv{F_2}{y}
    \end{equation}
    $$

- **Curl**: A measure of how much a vector field is rotating.

    $$
    \begin{equation}
    \curl{\va{F}(x, y)} = \pdv{F_2}{x} - \pdv{F_1}{y}
    \end{equation}
    $$

    It is positive when the vector field is rotating counterclockwise.
    The direction is given by the right-hand rule.

- **Laplacian**: A measure of how much a scalar field is curving, a multivariable generalization of the second derivative.

    $$
    \begin{equation}
    \laplacian{f(x, y)} = \pdv[2]{f}{x} + \pdv[2]{f}{y}
    \end{equation}
    $$

- **Harmonic Functions**: Functions that satisfy the Laplace equation, $\laplacian{f(x, y)} = 0$.
    These functions have the property that the neighbors are at the same height as the point itself on average.

- **Jacobian Matrix**: A matrix that represents the linear transformation of a vector field around a point.

    $$
    \begin{equation}
    \va{J}_{\va{F}} = \mqty[\pdv{f_1}{x} & \pdv{f_1}{y} \\ \pdv{f_2}{x} & \pdv{f_2}{y}]
    \end{equation}
    $$

    The Jacobian determinant measures how much the area of a square changes after the transformation.

