---
sidebar_position: 4
---

import { Mafs, Coordinates, Plot, Line, Circle, Theme, useMovablePoint, MovablePoint, useStopwatch, vec, Vector, LaTeX, Polygon, Transform, labelPi, Point, Text } from "mafs";
import MathEquation from "@site/src/components/Math";
import { useState, useEffect, useRef, useCallback, useMemo, memo, Fragment } from "react";
import { lineLabel } from "@site/src/utilities/lines";
import { color, getColorFromMagnitude, gradient } from "@site/src/utilities/colors";
import TOCInline from '@theme/TOCInline';
import * as MB from "mathbox-react";
import * as THREE from "three";
import range from "lodash/range";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { easeInOutCubic } from "js-easing-functions";

# Extending the Derivative: Part 2

Previously, we discussed some fundamentals in Multivariable Calculus, including the concept of partial derivatives and the gradient.
Now we will discuss some more advanced topics, and as a bonus, apply them to some real-world problems, including Maxwell's Equations.

We will cover the divergence, curl, and Laplacian **operators**. They are operators in that they take a function as input and return another function.
Operators have shown up before, such as the derivative operator $\dv{x}$, and the gradient operator $\grad$.

## Table of Contents

<TOCInline toc={toc} />

## Divergence

### Intuitition for Divergence

Before discussing the formula for divergence, let's first understand what it is.
Consider a vector field $\va{F}$ in 2D space. To drill in the intuition, consider it representing the flow of some water.

<DivergenceVisualization />

Consider a region in the space.
In this region, consider how much water is flowing in and out of the region. This is called the **divergence** of the vector field.
For example, set the region to be around the origin. Consider the following vector field:

<DivergenceVisualization
    f={([x, y]) => [x, y]}
    df={([x, y]) => [1, 1]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
    xRange={[-10, 10, 0.5]}
    yRange={[-10, 10, 0.5]}
    sources={[
        [0.5, 0],
        [0, 0.5],
        [-0.5, 0],
        [0, -0.5],
    ]}
/>

In this case, the water is flowing out of the region. In this case, the divergence is positive.
Note that a positive divergence doesn't mean that all the water is flowing out of the region. It just means that more water is flowing out than in.
For example, the divergence here is also positive:

<DivergenceVisualization
    f={([x, y]) => [(x + 7) / 5, 0]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
/>

Regions where the divergence is positive are called **sources**. In the water example, the source could be from a fountain.
Next, consider the following vector field:

<DivergenceVisualization f={([x, y]) => [-x, -y]} mafsNodes={<Circle center={[0, 0]} radius={2} />} />

We flipped the vector field, so now the water is flowing into the region, and the divergence is negative.
Regions where the divergence is negative are called **sinks**. In the water example, the sink could be a drain.

Of course, this is not how water works in real life. Going back to the first example:

<DivergenceVisualization />

Notice that at any region, there's no net flow of water. The water is flowing out of the region as much as it is flowing into the region.
Water is **incompressible**, and the mathematical term for this is that the divergence of the vector field is zero.

### Formulation of Divergence

The notation for divergence we will currently use is $\operatorname{div} \va{F}(x, y)$ (although this is not the only notation).
As shown above, divergence is a scalar value, and the operator acts on a vector field.

First, consider a vector field in one dimension:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ 0]
\end{equation}
$$

This means that the water will only flow horizontally. Consider the case where the divergence is positive:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0
\end{equation}
$$

What this means visually is that the water is flowing out of the region more than it is flowing in.
On the left side of the region, $P < 0$, and on the right side, $P > 0$.

A visualization is shown below, split into two parts:

1. The point $(x, y)$, and a movable point $P(x, y)$.
2. The plot of $P(x, y)$ over $x$ (with $y$ fixed).

export function DivergencePlot({
    P = (x) => x,
}) {
    const movable = useMovablePoint([-1, 0], {
        constrain: ([x, y]) => [x, 0],
    });
    const point = movable.point;

    const graphOrigin = [8.5, 0]
    return (
        <Mafs viewBox={{ x: [-5, 15]}}>
            <Vector tail={point} tip={vec.add(point, [P(point[0]), 0])} />
            {movable.element}

            <Point x={0} y={0} />
            <LaTeX tex={"(x, y)"} at={[0, -0.5]} />

            <Transform translate={graphOrigin} >
                <Vector tip={[4, 0]} />
                <Vector tip={[0, 4]} />
                <Vector tip={[-4, 0]} />
                <Vector tip={[0, -4]} />
                <LaTeX tex={"P(x, y)"} at={[0, 4.5]} />
                <LaTeX tex={"x"} at={[4.5, 0]} />
            </Transform>
            <Plot.Parametric
                xy={(t) => [
                    t,
                    P(t - graphOrigin[0]) + graphOrigin[1],
                ]}
                t={[graphOrigin[0] - 4, graphOrigin[0] + 4]}
            />
            <Point
                x={point[0] + graphOrigin[0]}
                y={P(point[0]) + graphOrigin[1]}
            />
        </Mafs>
    )
}

<DivergencePlot P={(x) => x} />

Meaning, it increases as we move to the right. This can be written as:

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

The second scenario is where there is a lot of water flowing out into the right, and some water flowing in from the left.
Recall that the divergence is still positive:

<DivergencePlot P={(x) => (x - 7) / 5 + 3} />

Notice that the slope of the graph is still positive, as it increases as we move to the right.

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

The last scenario is where there is a lot of water flowing out into the left, and some water flowing in from the right.

<DivergencePlot P={(x) => (x - 7) / 5} />

The slope of the graph is still positive, as it increases as we move to the right.
In this case, it's very negative at the left, and at the right, it is still negative, but less so. Hence,

$$
\begin{equation}
\pdv{P}{x} > 0
\end{equation}
$$

It should be clear from these scenarios that:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0 \implies \pdv{P}{x} > 0
\end{equation}
$$

Hence, the partial derivative is somehow related to the divergence.
We can apply the same logic for the $y$ component of the vector field:

$$
\begin{equation}
\va{F}(x, y) = \mqty[0 \\ Q(x, y)]
\end{equation}
$$

In this case, the water will only flow vertically. Consider the case where the divergence is positive:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) > 0 \implies \pdv{Q}{y} > 0
\end{equation}
$$

Now combine the two components:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

The divergence of this vector field is then defined as the sum of the partial derivatives of the components:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y}
\end{equation}
$$

There is something interesting about this formula. We only considered vector fields purely in the $x$ and $y$ directions.
In reality, vector fields can be in any direction. The formula for divergence still holds, since the vectors can always be decomposed into components in the $x$ and $y$ directions.
To use the intuitive example, you could consider a box around the origin, and consider the flow of water in and out of the box.
Then, the flow can be decomposed into the $x$ (left and right of the box) and $y$ (up and down of the box) directions.

### Example Problem: Evaluating Divergence

> The vector field $\va{F}(x, y)$ is given by:
>
> $$
> \begin{equation}
> \va{F}(x, y) = \mqty[x^2 + y^2 \\ 2xy]
> \end{equation}
> $$
>
> Evaluate the divergence of $\va{F}(x, y)$.

To evaluate the divergence, we need to find the partial derivatives of the components of the vector field.
Recall that partial derivatives are just like normal derivatives, but we treat the other variable as a constant.

First, define the components of the vector field:

$$
\begin{equation}
\va{F}(x, y) = \mqty[x^2 + y^2 \\ 2xy] = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Then, find the partial derivatives:

$$
\begin{align}
\pdv{P}{x} &= \pdv{}{x} (x^2 - y^2) = 2x \\
\pdv{Q}{y} &= \pdv{}{y} (2xy) = 2x
\end{align}
$$

Finally, evaluate the divergence:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y} = 2x + 2x = 4x
\end{equation}
$$

Hence, the divergence of $\va{F}(x, y)$ is $4x$.

<DivergenceVisualization
    f={([x, y]) => [x ** 2 - y ** 2, 2 * x * y]}
    df={([x, y]) => [4 * x, 0]}
    mafsNodes={<Circle center={[0, 0]} radius={2} />}
/>

Consider some cases:

- When $x > 0$, the divergence is positive, so the water is flowing out of the region.
- When $x < 0$, the divergence is negative, so the water is flowing into the region.
- When $x = 0$, the divergence is zero, so there is no net flow of water.

### Nabla Notation for Divergence

Recall the symbol $\grad$ used for the gradient. The gradient is defined as:

$$
\begin{equation}
\grad f(x, y) = \mqty[\pdv{f}{x} \\ \pdv{f}{y}]
\end{equation}
$$

Where we define $\grad$ as:

$$
\begin{equation}
\grad = \mqty[\pdv{x} \\ \pdv{y}]
\end{equation}
$$

The divergence is defined as:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \pdv{P}{x} + \pdv{Q}{y} = \pdv{x} P(x, y) + \pdv{y} Q(x, y)
\end{equation}
$$

This is equivalent to the dot product of the nabla operator and the vector field:

$$
\begin{equation}
\begin{split}
\operatorname{div} \va{F}(x, y) &= \class{blue}{\pdv{x}} \class{yellow}{P(x, y)} + \class{blue}{\pdv{y}} \class{yellow}{Q(x, y)} \\
&= \class{blue}{\mqty[\pdv{x} \\ \pdv{y}]} \cdot \class{yellow}{\mqty[P(x, y) \\ Q(x, y)]} \\
&= \class{blue}{\grad} \cdot \class{yellow}{\va{F}(x, y)}
\end{split}
\end{equation}
$$

Hence, the divergence can be written as:

$$
\begin{equation}
\operatorname{div} \va{F}(x, y) = \div \va{F}(x, y)
\end{equation}
$$

Not only does this have symbolic significance, but it also reflects another way to think about divergence intuitively, which will be discussed in [a later section](#interpretations-of-divergence-and-curl-with-its-formulas).

### The First Maxwell Equation: Gauss's Law

Now that we have discussed divergence, we can apply it to the first Maxwell equation: Gauss's Law.

It describes how the electric field $\class{yellow}{\va{E}}$ is related to the charge density $\rho$.

$$
\begin{equation}
\div \class{yellow}{\va{E}} = \frac{\rho}{\varepsilon_0}
\end{equation}
$$

This is a direct proportionality. This means that as the charge density increases, the divergence of the electric field increases, which should make intuitive sense.

Consider a positive charge somewhere in space.
The charge density would then be positive, so the divergence of the electric field would be positive.
This means that the electric field points away from the charge.

Likewise, for a negative charge, the charge density would be negative, so the divergence of the electric field would be negative.

{(() => {
    // positive charge
    const movablePositive = useMovablePoint([2, 0], { color: color("green") });
    const posPoint = movablePositive.point;

    // negative charge
    const movableNegative = useMovablePoint([-2, 0], { color: color("red") });
    const negPoint = movableNegative.point;

    const field = ([x, y]) => {
        const positive = vec.sub([x, y], posPoint);
        const negative = vec.sub([x, y], negPoint);
        const positiveMagnitude = vec.mag(positive);
        const negativeMagnitude = vec.mag(negative);
        return [
            positive[0] / (positiveMagnitude ** 3) - negative[0] / (negativeMagnitude ** 3),
            positive[1] / (positiveMagnitude ** 3) - negative[1] / (negativeMagnitude ** 3),
        ]
    }

    return (
        <DivergenceVisualization
            f={field}
            df={([x, y]) => [0, 0]}
            mafsNodes={[
                movablePositive.element,
                movableNegative.element,
            ]}
            sources={[posPoint]}
        />
    );
})()}

### The Second Maxwell Equation: Gauss's Law for Magnetism

The second Maxwell equation describes how the magnetic field $\class{blue}{\va{B}}$ is related to the divergence of the magnetic field.
It simply states that the divergence of the magnetic field is zero:

$$
\begin{equation}
\div \class{blue}{\va{B}} = 0
\end{equation}
$$

Recall that a divergence of zero means that it's incompressible, just like the water example.
The magnetic field lines are always closed loops, and they never start or end.

One implication is that there are no magnetic monopoles, hypothetical things that have only a north or south pole.

The first two Maxwell equations are the most intuitive, and they are the most straightforward to understand.
They describe in complete detail electro_statics_ and magneto_statics_ - when they are **not changing over time**.
When they do change over time, things get more complicated, and the two fields start to interact with each other.
These interactions are described by the last two Maxwell equations.

## Curl

### Intuition for Curl in 2D

Consider a vector field $\va{F}$ in 2D space. Once again, we will consider it representing the flow of some water.

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}
/>

Focus on this specific region:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[3, 0]} radius={1} />}
/>

Notice that the water is flowing counterclockwise around this point.
When there's rotation in the vector field, we call it the **curl** of the vector field.
For counterclockwise rotation, the curl is positive.

Consider another region:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[0, 3]} radius={1} />}
/>

In this region, the water is flowing clockwise around this point, so the curl is negative.

Finally, consider a region where the water does not rotate:

<DivergenceVisualization
    f={([x, y]) => [
        (y ** 3) / 3 - 3 * y,
        (x ** 3) / 3 - 3 * x,
    ]}
    xRange={[-4, 4, 0.5]}
    yRange={[-4, 4, 0.5]}

    mafsNodes={<Circle center={[0, 0]} radius={1} />}
/>

In this case, the curl is zero.

### Formulation of Curl in 2D

The notation for curl is $\operatorname{curl} \va{F}(x, y)$. A nabla notation also exists for curl, which will be discussed later.
Since we are considering 2D space, curl behaves a bit differerently, hence we shall use a different notation: $\operatorname{curl}_z \va{F}(x, y)$.

Decompose the vector field into components:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Consider the case where the curl is positive. This means that the water is rotating counterclockwise. Draw a point and some vectors around it:

<Mafs>
    <Point x={0} y={0} />
    <Vector tail={[-1, 0]} tip={[-1, -1]} />
    <Vector tail={[0, 1]} tip={[-1, 1]} />
    <Vector tail={[1, 0]} tip={[1, 1]} />
    <Vector tail={[0, -1]} tip={[1, -1]} />
</Mafs>

Label the signs of the vectors:

<Mafs>
    <Point x={0} y={0} />

    <Vector tail={[-1, 0]} tip={[-1, -1]} />
    <LaTeX tex={"Q < 0"} at={lineLabel([-1, 0], [-1, -1], "right", { sideOffset: 0.6 })} />

    <Vector tail={[0, 1]} tip={[-1, 1]} />
    <LaTeX tex={"P < 0"} at={lineLabel([0, 1], [-1, 1], "right", { sideOffset: 0.3 })} />

    <Vector tail={[1, 0]} tip={[1, 1]} />
    <LaTeX tex={"Q > 0"} at={lineLabel([1, 0], [1, 1], "right", { sideOffset: 0.6 })} />

    <Vector tail={[0, -1]} tip={[1, -1]} />
    <LaTeX tex={"P > 0"} at={lineLabel([0, -1], [1, -1], "right", { sideOffset: 0.3 })} />
</Mafs>

Hence, notice that the curl is positive when $P$ is decreasing in the $y$ direction and $Q$ is increasing in the $x$ direction.

Combining the two components, the curl is defined as:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y} \label{eq:formulation_of_curl_in_2d}
\end{equation}
$$

This also means that $P$ does not necessarily have to go from positive to negative, and $Q$ does not necessarily have to go from negative to positive.
In other words, both of these situations contribute the same to the curl:

<Mafs>
    <Transform translate={[-3, 0]}>
        <Vector tail={[-1, 0]} tip={[-1, -1]} />
        <Vector tail={[1, 0]} tip={[1, 1]} />
        <Point x={0} y={0} />
    </Transform>
    <Transform translate={[3, 0]}>
        <Vector tail={[-1, 0]} tip={[-1, 1]} />
        <Vector tail={[1, 0]} tip={[1, 2]} />
        <Point x={0} y={0} />
    </Transform>
</Mafs>

### Example Problem: Evaluating Curl

> The vector field $\va{v}(x, y)$ is given by:
>
> $$
> \begin{equation}
> \va{v}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x]
> \end{equation}
> $$
>
> Evaluate the curl of $\va{v}(x, y)$.

To evaluate the curl, we need to find the partial derivatives of the components of the vector field.
Define the components of the vector field:

$$
\begin{equation}
\va{v}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x] = \mqty[P(x, y) \\ Q(x, y)]
\end{equation}
$$

Then, find the partial derivatives:

$$
\begin{align}
\pdv{P}{y} &= \pdv{}{y} (y^3 - 9y) = 3y^2 - 9 \\
\pdv{Q}{x} &= \pdv{}{x} (x^3 - 9x) = 3x^2 - 9
\end{align}
$$

Finally, evaluate the curl:

$$
\begin{equation}
\operatorname{curl}_z \va{v}(x, y) = \pdv{Q}{x} - \pdv{P}{y} = 3x^2 - 9 - (3y^2 - 9) = 3x^2 - 3y^2
\end{equation}
$$

Hence, the curl of $\va{v}(x, y)$ is $3x^2 - 3y^2$.

### Three-Dimensional Rotation Vectors

Curl is related to rotation, so it's natural to consider how rotation works in 3D space before discussing the general formula for curl.

First consider 2D rotation. It can be described by a measure of the rotation speed, like 45 degrees per second.
For the direction, it depends on the sign of the rotation. Conventionally a positive rotation is counterclockwise.
Notice how, just with one number, we can describe 2D rotation in its entirety.

In 3D space, rotation is more complex:

1. First we need to consider the axis of rotation. This is where the rotation occurs about.
2. Next, we need to consider the magnitude and direction of the rotation - which is a vector. This is known as the **angular velocity**, denoted $\va{\omega}$.

<CustomMathbox>
    <MB.Cartesian>
        <MB.Matrix
            id="sphere"
            bufferWidth={128}
            bufferHeight={64}
            width={65}
            height={32}
            expr={(emit, i, j, time) => {
                let phi = (i / 64) * Math.PI * 2;
                let theta = (j / 31 - 0.5) * Math.PI;

                // rotate the sphere by w * time
                let w = 0.5;
                let x = Math.cos(phi) * Math.cos(theta);
                let y = Math.sin(theta);
                let z = Math.sin(phi) * Math.cos(theta);

                let x1 = x * Math.cos(w * time) - z * Math.sin(w * time);
                let z1 = x * Math.sin(w * time) + z * Math.cos(w * time);

                emit(
                    x1 / 2,
                    y / 2,
                    z1 / 2
                );
            }}
            channels={3}
        />
        <MB.Surface
            points="#sphere"
            color={"#B0B0B0"}
            lineX={true}
            lineY={true}
            opacity={0.75}
            zBias={-1}
        />

        <MB.Array
            items={2}
            id="rot1_vec"
            data={[
                [0, 0.5, 0],
                [0, 0.8, 0]
            ]}
            channels={3}
        />
        <MB.Vector end={true} points="#rot1_vec" color={color("blue")} />
        <MB.Array
            items={2}
            id="rot2_vec"
            data={[
                [0, -0.5, 0],
                [0, -0.8, 0]
            ]}
            channels={3}
        />
        <MB.Vector end={true} points="#rot2_vec" color={color("green")} />
    </MB.Cartesian>
</CustomMathbox>

The convention for the direction of the angular velocity vector is called the **right-hand rule**.
Take your right hand and curl your fingers in the direction of the rotation. Your thumb then points in the direction of the angular velocity vector.
Hence, in a single vector we can describe the axis of rotation, the direction of rotation, and the speed of rotation.

### Intuituion for Curl in 3D

Take the vector field $\va{F}$ defined previously as:

$$
\begin{equation}
\va{F}(x, y) = \mqty[y^3 - 9y \\ x^3 - 9x]
\end{equation}
$$

We have previously plotted the vector field in 2D space. Now, consider putting the same vector field in 3D space, on the $xy$ plane:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Area
            id="vector_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                // original point
                emit(x, 0, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.5);
                emit (
                    x + normalized[0],
                    0,
                    y + normalized[1],
                );
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Area
            id="vector_field_colors"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const mag = vec.mag(f);

                const [r, g, b] = getColorFromMagnitude(mag, 0, 20);
                emit(r, g, b, 1.0);
            }}
            width={20}
            height={20}
            channels={4}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            colors="#vector_field_colors"
            width={5}
            end={true}
        />
    </MB.Cartesian>
</CustomMathbox>

Next, consider the 2D curl of this vector field. Recall that the curl is defined as:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y}
\end{equation}
$$

The direction of the curl shall then be in the $z$ direction, defined via the right-hand rule. With this, we can plot some vectors representing the curl alongside the vector field:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Area
            id="vector_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                // original point
                emit(x, 0, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.5);
                emit(
                    x + normalized[0],
                    0,
                    y + normalized[1]
                );
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            color={color("yellow")}
            width={5}
            end={true}
        />

        <MB.Area
            id="curl_field"
            axes="xy"
            expr={(emit, y, x, i, t) => {
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const curlz = 3 * x ** 2 - 3 * y ** 2;
                emit(x, 0, y);
                emit(x, curlz / 75, y);
            }}
            items={2}
            width={20}
            height={20}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
        />
        <MB.Vector
            points="#curl_field"
            width={5}
            end={true}
            color={color("blue")}
        />
    </MB.Cartesian>
</CustomMathbox>

Notice that in areas of clockwise rotation, the curl is negative (points in the $-z$ direction), and in areas of counterclockwise rotation, the curl is positive (points in the $z$ direction).

The curl is a vector that purely exists in the $z$ direction. Hence, a prototype for the 3D curl could be, for a vector field $\va{F} = \mqty[P \\ Q]$:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{equation}
$$

However this does not fully capture the curl, since it only works on a 2D vector field.
To generalize this more, we need to do this for a vector field in 3D space. Recall our original vector field $\va{F}$:

$$
\begin{equation}
\va{F}(x, y) = \mqty[P(x, y) \\ Q(x, y)] = \mqty[y^3 - 9y \\ x^3 - 9x]
\end{equation}
$$

This results, as we've seen, in a vector field that lies on a plane.
Consider "copying" this vector for every $z$ value:

<CustomMathbox>
    <MB.Cartesian
        scale={[
            0.3, 0.3, 0.3
        ]}
    >
        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
        <MB.Volume
            id="vector_field"
            expr={(emit, y, z, x, i, t) => {
                // original point
                emit(x, z, y);
                const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                const normalized = vec.withMag(f, 0.75);
                emit(
                    x + normalized[0],
                    z,
                    y + normalized[1]
                );
            }}
            items={2}
            width={10}
            height={10}
            depth={10}
            channels={3}
            rangeX={[-4, 4]}
            rangeY={[-4, 4]}
            rangeZ={[-4, 4]}
        />
        <MB.Vector
            points="#vector_field"
            color={color("yellow")}
            width={3}
            end={true}
        />
    </MB.Cartesian>
</CustomMathbox>

Of course, only some of the vectors are visible. In reality, for every $z$ value, there is a plane in which the vector field exists.
Thus, the vector field can be thought of as a volume in 3D space:

$$
\begin{equation}
\va{F}(x, y\class{green}{, z}) = \mqty[P(x, y\class{green}{, z}) \\ Q(x, y\class{green}{, z}) \\ \class{green}{0}] = \mqty[y^3 - 9y \\ x^3 - 9x \\ 0]
\end{equation}
$$

We have:

1. Added a third input to the vector field, $z$. Notice that the output does not depend on $z$, which reflects the fact that the vector field does not change with $z$ (i.e. are copies of each other).
2. Added a third component to the vector field, which is always zero. This reflects how the vectors are all "flat".

Next, just like before, we can add the curl vectors to the vector field. Since the vector field is unchanging in the $z$ direction, the curl will also be unchanging in the $z$ direction.
This means that if you take a column somewhere in the vector field, the curl will be the same for all the vectors in that column.

{(() => {
    const [fieldVisible, setFieldVisible] = useState(true);
    const [curlVisible, setCurlVisible] = useState(true);
    return (
        <div className="card">
            <div className="card__body">
                <CustomMathbox>
                    <MB.Cartesian
                        scale={[
                            0.3, 0.3, 0.3
                        ]}
                    >
                        <MB.Axis axis="x" range={[-4, 4]} color={color("green")} />
                        <MB.Axis axis="y" range={[-4, 4]} color={color("blue")} />
                        <MB.Axis axis="z" range={[-4, 4]} color={color("yellow")} />
                        <MB.Group visible={fieldVisible}>
                            <MB.Volume
                                id="vector_field"
                                expr={(emit, y, z, x, i, t) => {
                                    // original point
                                    emit(x, z, y);
                                    const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                                    const normalized = vec.withMag(f, 0.75);
                                    emit(
                                        x + normalized[0],
                                        z,
                                        y + normalized[1]
                                    );
                                }}
                                items={2}
                                width={10}
                                height={10}
                                depth={10}
                                channels={3}
                                rangeX={[-4, 4]}
                                rangeY={[-4, 4]}
                                rangeZ={[-4, 4]}
                            />
                            <MB.Vector
                                points="#vector_field"
                                color={color("yellow")}
                                width={3}
                                end={true}
                            />
                        </MB.Group>
                        <MB.Group visible={curlVisible}>
                            <MB.Volume
                                id="curl_field"
                                expr={(emit, y, z, x, i, t) => {
                                    const f = [y ** 3 - 9 * y, x ** 3 - 9 * x];
                                    const curlz = 3 * x ** 2 - 3 * y ** 2;
                                    emit(x, z, y);
                                    emit(x, z + curlz / 75, y);
                                }}
                                items={2}
                                width={10}
                                height={10}
                                depth={10}
                                channels={3}
                                rangeX={[-4, 4]}
                                rangeY={[-4, 4]}
                                rangeZ={[-4, 4]}
                            />
                            <MB.Vector
                                points="#curl_field"
                                width={3}
                                end={true}
                                color={color("blue")}
                            />
                        </MB.Group>
                    </MB.Cartesian>
                </CustomMathbox>
            </div>
            <div className="card__footer">
                <button onClick={() => setFieldVisible(!fieldVisible)} className={`button button--block ${fieldVisible ? "button--primary" : "button--secondary"}`}>
                    {fieldVisible ? "Hide" : "Show"} Vector Field
                </button>
                <button onClick={() => setCurlVisible(!curlVisible)} className={`button button--block ${curlVisible ? "button--primary" : "button--secondary"}`}>
                    {curlVisible ? "Hide" : "Show"} Curl
                </button>
            </div>
        </div>
    );
})()}

Recall our prototype for the 3D curl:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}] = \mqty[0 \\ 0 \\ 3x^2 - 3y^2]
\end{equation}
$$

We can adjust this to include $z$ as an input:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y, z) \overset{?}{=} \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}] = \mqty[0 \\ 0 \\ 3x^2 - 3y^2]
\end{equation}
$$

We're not done yet. Recall that $\va{F}$ is defined such that it is constant in the $z$ direction.
For vector fields that are *not* constant in the $z$ direction, the curl will be different.

The problem with 3D vector fields is that it is difficult to visualize the direction of rotation.
One way to think about it is to consider hovering a ball in the vector field, and letting the fluid flow around it, causing it to rotate.

### Formulation of Curl in 3D

To formulate the curl in 3D, consider a vector field $\va{F}$:

$$
\begin{equation}
\va{F}(x, y, z) = \mqty[P(x, y, z) \\ Q(x, y, z) \\ R(x, y, z)]
\end{equation}
$$

Since curl has a direction, we expect the curl to output some 3D vector as well.
This formula is usually written in terms of the nabla operator:

$$
\begin{equation}
\operatorname{curl} \va{F}(x, y, z) = \curl \va{F}(x, y, z)
\end{equation}
$$

Where the nabla operator is defined as $\grad = \mqty[\pdv{x} \\ \pdv{y} \\ \pdv{z}]$.
Recall the 2D curl formula from Equation $\eqref{eq:formulation_of_curl_in_2d}$:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \pdv{Q}{x} - \pdv{P}{y}
\end{equation}
$$

We can take our 3D curl formula and treat it as a generalization of the 2D curl formula. Then, the curl in 2D is defined as a special case:

$$
\begin{equation}
\operatorname{curl}_z \va{F}(x, y) = \curl \va{F}(x, y) = \mqty[\pdv{x} \\ \pdv{y}] \times \mqty[P(x, y) \\ Q(x, y)] = \mqty[0 \\ 0 \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{equation}
$$

This aligns with our previous definition of curl in 2D in Equation $\eqref{eq:formulation_of_curl_in_2d}$.

For a 3D vector field, recall that the cross product can be defined as the determinant of a certain matrix:

$$
\begin{equation}
\va{A} \times \va{B} = \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ A_x & A_y & A_z \\ B_x & B_y & B_z]
\end{equation}
$$

So, the curl of a 3D vector field is hence defined as:

$$
\begin{equation}
\begin{split}
\operatorname{curl} \va{F}(x, y, z) &= \class{yellow}{\nabla} \times \class{green}{\va{F}(x, y, z)} \\
&= \class{yellow}{\mqty[\pdv{x} \\ \pdv{y} \\ \pdv{z}]} \times \class{green}{\mqty[P(x, y, z) \\ Q(x, y, z) \\ R(x, y, z)]} \\
&= \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ \class{yellow}{\pdv{x}} & \class{yellow}{\pdv{y}} & \class{yellow}{\pdv{z}} \\ \class{green}{P} & \class{green}{Q} & \class{green}{R}]
\end{split}
\end{equation}
$$

This is an absurd notational trick. We have a matrix of:

- The unit vectors $\vu{i}$, $\vu{j}$, and $\vu{k}$. Matrices should not have vectors as elements.
- Partial differential operators.
- The components of the vector field, which are all multivariable functions.

To compute the determinant, we:

1. First take $\vu{i}$ and the submatrix formed by removing the row and column of $\vu{i}$.
2. Multiply $\vu{i}$ by the determinant of this submatrix.
3. Repeat this for $\vu{j}$ and $\vu{k}$.

This results in:

$$
\begin{equation}
\begin{split}
\operatorname{curl} \va{F}(x, y, z) &= \det \mqty[\vu{i} & \vu{j} & \vu{k} \\ \pdv{x} & \pdv{y} & \pdv{z} \\ P & Q & R] \\
&= \vu{i}\qty(\pdv{Q}{z} - \pdv{R}{y}) - \vu{j}\qty(\pdv{P}{z} - \pdv{R}{x}) + \vu{k}\qty(\pdv{P}{y} - \pdv{Q}{x}) \\
&= \mqty[\pdv{R}{y} - \pdv{Q}{z} \\ \pdv{P}{z} - \pdv{R}{x} \\ \pdv{Q}{x} - \pdv{P}{y}]
\end{split}
\end{equation}
$$

Notice the third term $\vu{k}\qty(\pdv{P}{y} - \pdv{Q}{x})$. This is the same as the 2D curl formula, with $k$ added to it.
This should make conceptual sense.

### The Third Maxwell Equation: Faraday's Law

Faraday's law is one of the four Maxwell equations, which describe how a changing magnetic field induces an electric field.
It is given by:

$$
\begin{equation}
\curl \class{yellow}{\va{E}} = -\pdv{\class{blue}{\va{B}}}{t}
\end{equation}
$$

Where $\class{yellow}{\va{E}}$ is the electric field and $\class{blue}{\va{B}}$ is the magnetic field.
We can dissect this equation and intuitively understand it.

Consider a magnet on a table. The magnet creates a magnetic field around it, and this field changes when the magnet is moved.

{(() => {
    const magPoint = useMovablePoint([0, 0], {
        constrain: ([x, y]) => [x, 0],
    });
    return (
        <Mafs>
            <Line.PointSlope point={[0, -0.5]} slope={0} /> {/* table */}
            <Transform translate={magPoint.point}>
                <Polygon
                    points={[
                        [0, -0.5],
                        [0, 0.5],
                        [2, 0.5],
                        [2, -0.5],
                    ]}
                    color={color("red")}
                />
                <Text x={0.5} y={0}>N</Text>

                <Polygon
                    points={[
                        [2, -0.5],
                        [2, 0.5],
                        [4, 0.5],
                        [4, -0.5],
                    ]}
                    color={color("blue")}
                />
                <Text x={3.5} y={0}>S</Text>
            </Transform>
            {magPoint.element}
        </Mafs>
    );
})()}

## Interpretations of Divergence and Curl with its Formulas

An interesting way to think about divergence and curl is to consider the formulas for each:

$$
\begin{align}
\operatorname{div} \va{F}(x, y, z) &= \div \va{F}(x, y, z) \\
\operatorname{curl} \va{F}(x, y, z) &= \curl \va{F}(x, y, z)
\end{align}
$$

Recall the geometric properties of the dot and cross products:

- The dot product is the highest when the two vectors are in the same direction.
- The cross product is the highest when the two vectors are perpendicular.

Recall that the gradient describes how a function changes in space. Consider a point in space, and a step in the $x$ direction.
Draw a vector for both points:

<Mafs>
    <Transform translate={[-0.5, 0]}>
        <Point x={0} y={0} />
        <LaTeX tex="\vec{\mathbf{r}}" at={[0, -0.5]} />
        <Vector tip={[0, 1]} />
    </Transform>
    <Vector tail={[-0.5, 0]} tip={[0.5, 0]} />
    <Transform translate={[0.5, 0]}>
        <Point x={0} y={0} />
        <LaTeX tex="\vec{\mathbf{r}} + \Delta \vec{\mathbf{r}}" at={[0, -0.5]} />
        <Vector tip={[0.5, 1]} />
    </Transform>
</Mafs>

Consider the difference between the two vectors. In some sense, this represents how the vector field changes with the step.
As the divergence increases, then the direction of this difference should be in the direction of the step itself; an outward step should result in an outward difference.

Next, recall that the dot product is the highest when the two vectors are in the same direction.
Hence, the dot product of the gradient and the vector field should be the highest when the gradient is in the direction of the vector field.
This is the case when the divergence is positive.

<Mafs>
    <Point x={0} y={0} />
    {range(0, 2 * Math.PI, Math.PI / 4).map((angle) => (
        <Fragment key={angle}>
            <Vector
                tail={[0, 0]}
                tip={[Math.cos(angle), Math.sin(angle)]}
            />
            <Vector
                tail={[Math.cos(angle), Math.sin(angle)]}
                tip={[1.5 * Math.cos(angle), 1.5 * Math.sin(angle)]}
                color={color("red")}
            />
        </Fragment>
    ))}
    <LaTeX
        tex="\htmlClass{red}{\text{(change in output)}} \cdot \text{(step)}"
        at={[0, -2]}
        katexOptions={{
            // allow html tags
            trust: (context) => context.command === "\\htmlClass",
            strict: false,
        }}
    />
</Mafs>

Compare this to the curl. The cross product is the highest when the two vectors are perpendicular.
As such, the curl should be the highest when the gradient is perpendicular to the vector field.

<Mafs>
    <Point x={0} y={0} />
    {range(0, 2 * Math.PI, Math.PI / 4).map((angle) => (
        <Fragment key={angle}>
            <Vector
                tail={[0, 0]}
                tip={[Math.cos(angle), Math.sin(angle)]}
            />
            <Vector
                tail={[Math.cos(angle), Math.sin(angle)]}
                tip={[
                    // rotate by 90 degrees
                    Math.cos(angle) + Math.sin(angle),
                    Math.sin(angle) - Math.cos(angle),
                ]}
                color={color("red")}
            />
        </Fragment>
    ))}
    <LaTeX
        tex="\htmlClass{red}{\text{(change in output)}} \times \text{(step)}"
        at={[0, -2]}
        katexOptions={{
            // allow html tags
            trust: (context) => context.command === "\\htmlClass",
            strict: false,
        }}
    />
</Mafs>

This is why the curl is highest when the vector field is rotating the fastest.

## Laplacian

The Laplacian is another operator for vector fields. It gives a scalar field as an output, and can be thought of as the multivariable generalization of the second derivative.
It is sometimes written as:

$$
\begin{equation}
\operatorname{Lap} \va{F}(x, y) = \operatorname{div} (\operatorname{grad} \va{F}(x, y))
\end{equation}
$$

This can be expanded out as:

$$
\begin{equation}
\operatorname{Lap} \va{F}(x, y) = \div \grad \va{F}(x, y) = \laplacian \va{F}(x, y)
\end{equation}
$$

### Intuition for Laplacian


